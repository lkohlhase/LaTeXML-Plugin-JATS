<?xml version="1.0" encoding="UTF-8"?>
<?latexml searchpaths="/home/lnk/Desktop/LaTeXML-Plugin-JATS/development"?>
<?latexml class="revtex4-1" options="a4,12pt,notitlepage"?>
<?latexml package="dcolumn"?>
<?latexml package="bm"?>
<?latexml package="graphicx"?>
<?latexml package="float"?>
<?latexml package="multirow"?>
<?latexml package="booktabs"?>
<?latexml package="array"?>
<?latexml package="paralist"?>
<?latexml package="verbatim"?>
<?latexml package="subfigure"?>
<?latexml package="rotating"?>
<?latexml package="geometry" options="left=2cm,right=2cm,top=2.5cm,bottom=2.5cm"?>
<?latexml package="fancyhdr"?>
<!-- %options: empty , plain , fancy -->
<!-- %**** ppi-main.tex Line 25 **** -->
<!-- %customise the layout... -->
<?latexml package="threeparttablex"?>
<?latexml package="amsmath"?>
<?latexml package="tikz-inet"?>
<?latexml RelaxNGSchema="LaTeXML"?>
<?latexml package="circuitikz"?>
<?latexml package="xcolor"?>
<document xmlns="http://dlmf.nist.gov/LaTeXML" class="ltx_authors_1line" xml:id="Document">
  <resource src="LaTeXML.css" type="text/css"/>
  <resource src="ltx-article.css" type="text/css"/>
  <title>Quantum IsoRank: Efficient Alignment of Multiple PPI Networks</title>
  <creator role="author">
    <personname>Anmer Daskin</personname>
    <contact role="email">email:anmerdaskin@yahoo.com</contact>
    <contact role="affiliation">Department of Computer Engineering, Istanbul Medeniyet University, Uskudar, Istanbul, Turkey</contact>
  </creator>
  <abstract name="Abstract">
    <p>Comparative analyses of protein-protein interaction networks play important roles in the understanding of biological processes.
The growing enormity of available data on the networks becomes a computational challenge for the conventional alignment algorithms. Quantum algorithms generally provide efficiency over their classical counterparts in solving various problems. One of such algorithms is the quantum phase estimation algorithm which generates the principal eigenvector of a stochastic matrix with probability one.
Using this property, in this article, we describe a quantum computing approach for the alignment of protein-protein interaction networks by following the classical algorithm IsoRank which uses the principal eigenvector of the stochastic matrix representing the Kronecker product of the normalized adjacency matrices of networks for the pairwise alignment.
We also present a measurement scheme to efficiently procure the alignment from the output state of the phase estimation algorithm where the eigenvector is encoded as the amplitudes of this state.
Furthermore,
since the stochastic matrices are generally not Hermitian, we discuss how to approximate such matrices and generate quantum circuits. Finally we discuss the complexity of the quantum approach and show that it is exponentially more efficient.</p>
  </abstract>
  <ERROR class="undefined">\usetikzlibrary</ERROR>
  <para xml:id="p1" fragid="p1">
    <p>graphs,trees,shapes,snakes,arrows,circuits.logic.US<ERROR class="undefined">\usetikzlibrary</ERROR>backgrounds,fit,decorations.pathreplacing<ERROR class="undefined">\tikzstyle</ERROR>branch=[fill,shape=circle,minimumsize=3pt,innersep=0pt]<!-- %Dirac Kets 
     %Dirac Kets-->


<!-- %**** ppi-main.tex Line 50 **** --></p>
  </para>
  <section refnum="1" xml:id="S1" fragid="S1">
    <title><tag close=" ">1</tag>Introduction</title>
    <para xml:id="S1.p1" fragid="S1.p1">
      <p>Comparative analyses of protein-protein interaction (PPI) networks play important roles in the understanding of biological processes.
Alignments of PPI networks drawn from different species provide invaluable information to catalogue conserved network regions and identify functional similarities across species.
Using different formulations, many network alignment algorithms have been proposed such as the ones
in ref. <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx1" idref="bib.bibx1">Klau(2009)</ref>, <ref href="#bib.bibx2" idref="bib.bibx2">Kelley <emph>et al.</emph>(2004)Kelley,
Yuan, Lewitter, Sharan,
Stockwell, and Ideker</ref>, <ref href="#bib.bibx3" idref="bib.bibx3">Koyutürk <emph>et al.</emph>(2006)Koyutürk, Kim, Topkara, Subramaniam, Szpankowski, and Grama</ref>, <ref href="#bib.bibx4" idref="bib.bibx4">Li <emph>et al.</emph>(2007)Li,
Zhang, Wang, Zhang, and Chen</ref>, <ref href="#bib.bibx5" idref="bib.bibx5">Zaslavskiy <emph>et al.</emph>(2009)Zaslavskiy, Bach, and Vert</ref>]</cite> and others <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx6" idref="bib.bibx6">Clark and Kalita(2014)</ref>]</cite>. However, the growing enormity of available data on the networks raises computational challenges for implementations of these algorithms.
In analogous to ranking algorithms, e.g. PageRank <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx7" idref="bib.bibx7">Page <emph>et al.</emph>(1999)Page,
Brin, Motwani, and Winograd</ref>]</cite>, one of the global alignment algorithms, IsoRank <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx8" idref="bib.bibx8">Singh <emph>et al.</emph>(2007)Singh,
Xu, and Berger</ref>]</cite>, uses the intuition that the score of aligning two nodes should depend on the alignment of their neighbours in the global alignment of two PPI networks.
It formulates the network alignment as an eigenvector problem where coefficients of the principal eigenvector of a stochastic matrix, the stationary state, represent the functional similarity scores between pairs of the nodes.
Using a greedy algorithm, it then generates the network alignment from the eigenvector.
In the case of multiple networks, IsoRank is applied to every pair of the networks and a global alignment is retrieved from the pairwise network alignment results <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx9" idref="bib.bibx9">Liao <emph>et al.</emph>(2009)Liao,
Lu, Baym, 0001, and Berger</ref>]</cite>.
While IsoRank is one of the successful algorithms and fast enough to handle the alignment of large sparse graphs <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx10" idref="bib.bibx10">Bayati <emph>et al.</emph>(2009)Bayati,
Gerritsen, Gleich, Saberi, and Wang</ref>]</cite>,
the exponential scaling of its running time with the number of networks still impedes applications of the algorithm to multiple networks (the running time of the algorithm is <Math mode="inline" xml:id="S1.p1.m1" tex="O(E^{m})" text="O * E ^ m" fragid="S1.p1.m1"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">O</XMTok><XMDual><XMRef idref="S1.p1.m1.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMApp xml:id="S1.p1.m1.1" fragid="S1.p1.m1.1"><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">E</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok></XMApp><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMath></Math> where <Math mode="inline" xml:id="S1.p1.m2" tex="E" text="E" fragid="S1.p1.m2"><XMath><XMTok role="UNKNOWN" font="italic">E</XMTok></XMath></Math> is the
number of edges in a network and <Math mode="inline" xml:id="S1.p1.m3" tex="m" text="m" fragid="S1.p1.m3"><XMath><XMTok role="UNKNOWN" font="italic">m</XMTok></XMath></Math> is the number of networks) <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx11" idref="bib.bibx11">Nir <emph>et al.</emph>(2008)Nir,
Roded, and William Stafford</ref>]</cite>.</p>
    </para>
    <!-- %**** ppi-main.tex Line 75 **** -->
    <para xml:id="S1.p2" fragid="S1.p2">
      <p>In ref.<cite class="ltx_citemacro_cite">[<ref href="#bib.bibx12" idref="bib.bibx12">Daskin <emph>et al.</emph>(2014)Daskin,
Grama, and Kais</ref>]</cite>, it has been discussed that aligning networks on quantum computers may provide efficiency.
In particular, it is shown that the quantum phase estimation algorithm can be used for stochastic matrices to find their principal eigenvector with the success probability one.
However, it has not been shown how to procure a solution from the quantum state representing the principal eigenvector.
It is also not shown how to simulate ranking matrices which are not Hermitian in most of the cases in the phase estimation algorithm.
Here, we first show explicitly how the eigenvector of a stochastic matrix can be obtained by using the phase estimation algorithm.
To construct the alignment from the final quantum state, we then give an efficient greedy quantum algorithm based on a quantum measurement scheme.
In addition, we present an approximate simulation approach for non Hermitian ranking matrices and present simple examples with numerical results which can be experimented on quantum computers (The capacities of the current quantum computers are very limited.
Thus, they can only run for small sized problems.). In the end, the complexity analysis shows that the multiple network alignment by this quantum approach requires
<Math mode="inline" xml:id="S1.p2.m1" tex="O\Big(m\times poly\big(log(|V|)\big)\Big)" text="O * m * p * o * l * y * l * o * g * absolute-value@(V)" fragid="S1.p2.m1"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">O</XMTok><XMDual><XMRef idref="S1.p2.m1.2"/><XMWrap><XMTok role="OPEN" stretchy="false" fontsize="160%">(</XMTok><XMApp xml:id="S1.p2.m1.2" fragid="S1.p2.m1.2"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok meaning="times" role="MULOP">×</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok><XMTok role="UNKNOWN" font="italic">p</XMTok></XMApp><XMTok role="UNKNOWN" font="italic">o</XMTok><XMTok role="UNKNOWN" font="italic">l</XMTok><XMTok role="UNKNOWN" font="italic">y</XMTok><XMDual><XMRef idref="S1.p2.m1.2.1"/><XMWrap><XMTok role="OPEN" stretchy="false" fontsize="120%">(</XMTok><XMApp xml:id="S1.p2.m1.2.1" fragid="S1.p2.m1.2.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">l</XMTok><XMTok role="UNKNOWN" font="italic">o</XMTok><XMTok role="UNKNOWN" font="italic">g</XMTok><XMDual><XMRef idref="S1.p2.m1.2.1.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMDual xml:id="S1.p2.m1.2.1.1" fragid="S1.p2.m1.2.1.1"><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S1.p2.m1.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMTok role="UNKNOWN" xml:id="S1.p2.m1.1" font="italic" fragid="S1.p2.m1.1">V</XMTok><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp><XMTok role="CLOSE" stretchy="false" fontsize="120%">)</XMTok></XMWrap></XMDual></XMApp><XMTok role="CLOSE" stretchy="false" fontsize="160%">)</XMTok></XMWrap></XMDual></XMApp></XMath></Math> computational running time for sparse matrices while <Math mode="inline" xml:id="S1.p2.m2" tex="O\big(m|V|^{2}\big)" text="O * m * (absolute-value@(V)) ^ 2" fragid="S1.p2.m2"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">O</XMTok><XMDual><XMRef idref="S1.p2.m2.2"/><XMWrap><XMTok role="OPEN" stretchy="false" fontsize="120%">(</XMTok><XMApp xml:id="S1.p2.m2.2" fragid="S1.p2.m2.2"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S1.p2.m2.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMTok role="UNKNOWN" xml:id="S1.p2.m2.1" font="italic" fragid="S1.p2.m2.1">V</XMTok><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp><XMTok role="CLOSE" stretchy="false" fontsize="120%">)</XMTok></XMWrap></XMDual></XMApp></XMath></Math> for dense matrices. This provides an exponential efficiency over the classical running time.</p>
    </para>
  </section>
  <section refnum="2" xml:id="S2" fragid="S2">
    <title><tag close=" ">2</tag>Classical IsoRank</title>
    <para xml:id="S2.p1" fragid="S2.p1">
      <p>A PPI network is generally represented as an undirected graph,
<Math mode="inline" xml:id="S2.p1.m1" tex="G(V,E)" text="G * open-interval@(V, E)" fragid="S2.p1.m1"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">G</XMTok><XMDual><XMApp><XMTok meaning="open-interval"/><XMRef idref="S2.p1.m1.1"/><XMRef idref="S2.p1.m1.2"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMTok role="UNKNOWN" xml:id="S2.p1.m1.1" font="italic" fragid="S2.p1.m1.1">V</XMTok><XMTok role="PUNCT">,</XMTok><XMTok role="UNKNOWN" xml:id="S2.p1.m1.2" font="italic" fragid="S2.p1.m1.2">E</XMTok><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMath></Math> where the set of nodes <Math mode="inline" xml:id="S2.p1.m2" tex="V" text="V" fragid="S2.p1.m2"><XMath><XMTok role="UNKNOWN" font="italic">V</XMTok></XMath></Math> represents the set of proteins and the set of edges <Math mode="inline" xml:id="S2.p1.m3" tex="(v_{i},v_{j})\in E" text="open-interval@(v _ i, v _ j) element-of E" fragid="S2.p1.m3"><XMath><XMApp><XMTok meaning="element-of" name="in" role="RELOP">∈</XMTok><XMDual><XMApp><XMTok meaning="open-interval"/><XMRef idref="S2.p1.m3.1"/><XMRef idref="S2.p1.m3.2"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMApp xml:id="S2.p1.m3.1" fragid="S2.p1.m3.1"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">v</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp><XMTok role="PUNCT">,</XMTok><XMApp xml:id="S2.p1.m3.2" fragid="S2.p1.m3.2"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">v</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual><XMTok role="UNKNOWN" font="italic">E</XMTok></XMApp></XMath></Math>
describes interactions between proteins <Math mode="inline" xml:id="S2.p1.m4" tex="v_{i}" text="v _ i" fragid="S2.p1.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">v</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S2.p1.m5" tex="v_{j}" text="v _ j" fragid="S2.p1.m5"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">v</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math>.
To observe conserved similarities across species, PPI networks for different species are comparatively analysed by maximizing an objective function to indicate correspondences between the nodes.
Singh et al.<cite class="ltx_citemacro_cite">[<ref href="#bib.bibx8" idref="bib.bibx8">Singh <emph>et al.</emph>(2007)Singh,
Xu, and Berger</ref>]</cite> have presented a global alignment algorithm, viz. IsoRank, by using the intuition that the score of aligning two nodes should depend on the alignment of their neighbours. This intuition is formulated as follows:</p>
      <equation frefnum="(1)" refnum="1" xml:id="S2.E1" labels="LABEL:Eq:sing1" fragid="S2.E1">
        <Math mode="display" xml:id="S2.E1.m1" tex="R_{ij}=\displaystyle\sum_{u\in N(i)}\sum_{v\in N(j)}\frac{1}{|N(u)||N(v)|}R_{%&#10;uv}," text="R _ (i * j) = (sum _ (u element-of N * i))@((sum _ (v element-of N * j))@((1 / (absolute-value@(N * u) * absolute-value@(N * v))) * R _ (u * v)))" fragid="S2.E1.m1">
          <XMath>
            <XMApp punctuation=",">
              <XMTok meaning="equals" role="RELOP">=</XMTok>
              <XMApp>
                <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                <XMTok role="UNKNOWN" font="italic">R</XMTok>
                <XMApp>
                  <XMTok meaning="times" role="MULOP">⁢</XMTok>
                  <XMTok role="UNKNOWN" font="italic">i</XMTok>
                  <XMTok role="UNKNOWN" font="italic">j</XMTok>
                </XMApp>
              </XMApp>
              <XMApp>
                <XMApp scriptpos="mid">
                  <XMTok role="SUBSCRIPTOP" scriptpos="mid2"/>
                  <XMTok mathstyle="display" meaning="sum" role="SUMOP" scriptpos="mid">∑</XMTok>
                  <XMApp>
                    <XMTok meaning="element-of" name="in" role="RELOP">∈</XMTok>
                    <XMTok role="UNKNOWN" font="italic">u</XMTok>
                    <XMApp>
                      <XMTok meaning="times" role="MULOP">⁢</XMTok>
                      <XMTok role="UNKNOWN" font="italic">N</XMTok>
                      <XMDual>
                        <XMRef idref="S2.E1.m1.1"/>
                        <XMWrap>
                          <XMTok role="OPEN" stretchy="false">(</XMTok>
                          <XMTok role="UNKNOWN" xml:id="S2.E1.m1.1" font="italic" fragid="S2.E1.m1.1">i</XMTok>
                          <XMTok role="CLOSE" stretchy="false">)</XMTok>
                        </XMWrap>
                      </XMDual>
                    </XMApp>
                  </XMApp>
                </XMApp>
                <XMApp>
                  <XMApp scriptpos="mid">
                    <XMTok role="SUBSCRIPTOP" scriptpos="mid2"/>
                    <XMTok mathstyle="display" meaning="sum" role="SUMOP" scriptpos="mid">∑</XMTok>
                    <XMApp>
                      <XMTok meaning="element-of" name="in" role="RELOP">∈</XMTok>
                      <XMTok role="UNKNOWN" font="italic">v</XMTok>
                      <XMApp>
                        <XMTok meaning="times" role="MULOP">⁢</XMTok>
                        <XMTok role="UNKNOWN" font="italic">N</XMTok>
                        <XMDual>
                          <XMRef idref="S2.E1.m1.2"/>
                          <XMWrap>
                            <XMTok role="OPEN" stretchy="false">(</XMTok>
                            <XMTok role="UNKNOWN" xml:id="S2.E1.m1.2" font="italic" fragid="S2.E1.m1.2">j</XMTok>
                            <XMTok role="CLOSE" stretchy="false">)</XMTok>
                          </XMWrap>
                        </XMDual>
                      </XMApp>
                    </XMApp>
                  </XMApp>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok mathstyle="display" meaning="divide" role="MULOP"/>
                      <XMTok meaning="1" role="NUMBER">1</XMTok>
                      <XMApp>
                        <XMTok meaning="times" role="MULOP">⁢</XMTok>
                        <XMDual>
                          <XMApp>
                            <XMTok meaning="absolute-value"/>
                            <XMRef idref="S2.E1.m1.5"/>
                          </XMApp>
                          <XMWrap>
                            <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                            <XMApp xml:id="S2.E1.m1.5" fragid="S2.E1.m1.5">
                              <XMTok meaning="times" role="MULOP">⁢</XMTok>
                              <XMTok role="UNKNOWN" font="italic">N</XMTok>
                              <XMDual>
                                <XMRef idref="S2.E1.m1.3"/>
                                <XMWrap>
                                  <XMTok role="OPEN" stretchy="false">(</XMTok>
                                  <XMTok role="UNKNOWN" xml:id="S2.E1.m1.3" font="italic" fragid="S2.E1.m1.3">u</XMTok>
                                  <XMTok role="CLOSE" stretchy="false">)</XMTok>
                                </XMWrap>
                              </XMDual>
                            </XMApp>
                            <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                          </XMWrap>
                        </XMDual>
                        <XMDual>
                          <XMApp>
                            <XMTok meaning="absolute-value"/>
                            <XMRef idref="S2.E1.m1.6"/>
                          </XMApp>
                          <XMWrap>
                            <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                            <XMApp xml:id="S2.E1.m1.6" fragid="S2.E1.m1.6">
                              <XMTok meaning="times" role="MULOP">⁢</XMTok>
                              <XMTok role="UNKNOWN" font="italic">N</XMTok>
                              <XMDual>
                                <XMRef idref="S2.E1.m1.4"/>
                                <XMWrap>
                                  <XMTok role="OPEN" stretchy="false">(</XMTok>
                                  <XMTok role="UNKNOWN" xml:id="S2.E1.m1.4" font="italic" fragid="S2.E1.m1.4">v</XMTok>
                                  <XMTok role="CLOSE" stretchy="false">)</XMTok>
                                </XMWrap>
                              </XMDual>
                            </XMApp>
                            <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                          </XMWrap>
                        </XMDual>
                      </XMApp>
                    </XMApp>
                    <XMApp>
                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                      <XMTok role="UNKNOWN" font="italic">R</XMTok>
                      <XMApp>
                        <XMTok meaning="times" role="MULOP">⁢</XMTok>
                        <XMTok role="UNKNOWN" font="italic">u</XMTok>
                        <XMTok role="UNKNOWN" font="italic">v</XMTok>
                      </XMApp>
                    </XMApp>
                  </XMApp>
                </XMApp>
              </XMApp>
            </XMApp>
          </XMath>
        </Math>
      </equation>
      <p>where, <Math mode="inline" xml:id="S2.p1.m6" tex="N(a)" text="N * a" fragid="S2.p1.m6"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">N</XMTok><XMDual><XMRef idref="S2.p1.m6.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMTok role="UNKNOWN" xml:id="S2.p1.m6.1" font="italic" fragid="S2.p1.m6.1">a</XMTok><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMath></Math> is the set of neighbours of the node <Math mode="inline" xml:id="S2.p1.m7" tex="a" text="a" fragid="S2.p1.m7"><XMath><XMTok role="UNKNOWN" font="italic">a</XMTok></XMath></Math>; <Math mode="inline" xml:id="S2.p1.m8" tex="|N(a)|" text="absolute-value@(N * a)" fragid="S2.p1.m8"><XMath><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S2.p1.m8.2"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S2.p1.m8.2" fragid="S2.p1.m8.2"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">N</XMTok><XMDual><XMRef idref="S2.p1.m8.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMTok role="UNKNOWN" xml:id="S2.p1.m8.1" font="italic" fragid="S2.p1.m8.1">a</XMTok><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual></XMath></Math> is the size of this set;
<Math mode="inline" xml:id="S2.p1.m9" tex="V_{1}" text="V _ 1" fragid="S2.p1.m9"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S2.p1.m10" tex="V_{2}" text="V _ 2" fragid="S2.p1.m10"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> are the set of the nodes for the networks <Math mode="inline" xml:id="S2.p1.m11" tex="G_{1}" text="G _ 1" fragid="S2.p1.m11"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S2.p1.m12" tex="G_{2}" text="G _ 2" fragid="S2.p1.m12"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>; and <Math mode="inline" xml:id="S2.p1.m13" tex="i\in V_{1}" text="i element-of V _ 1" fragid="S2.p1.m13"><XMath><XMApp><XMTok meaning="element-of" name="in" role="RELOP">∈</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMath></Math> and
<Math mode="inline" xml:id="S2.p1.m14" tex="j\in V_{2}" text="j element-of V _ 2" fragid="S2.p1.m14"><XMath><XMApp><XMTok meaning="element-of" name="in" role="RELOP">∈</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMath></Math>. <Math mode="inline" xml:id="S2.p1.m15" tex="R" text="R" fragid="S2.p1.m15"><XMath><XMTok role="UNKNOWN" font="italic">R</XMTok></XMath></Math> defines the functional similarity matrix whose stationary state is
used to find the solution for the alignment problem. Eq.(<ref labelref="LABEL:Eq:sing1" href="#S2.E1" title="(1) ‣ 2 Classical IsoRank ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">1</text></ref>) can be rewritten also in matrix form as:</p>
    </para>
    <!-- %**** ppi-main.tex Line 100 **** -->
    <para xml:id="S2.p2" fragid="S2.p2">
      <equation frefnum="(2)" refnum="2" xml:id="S2.E2" labels="LABEL:Eq:IsoRank1" fragid="S2.E2">
        <Math mode="display" xml:id="S2.E2.m1" tex="\begin{split}\displaystyle R&amp;\displaystyle=AR,\\&#10;\displaystyle A[i,j][u,v]&amp;\displaystyle=\Big\{\begin{matrix}\frac{1}{|N(u)||N(%&#10;v)|}&amp;\text{if $(i,u)\in E_{1}$ and $(j,v)\in E_{2}$,}\\&#10;0&amp;\text{otherwise.}\end{matrix}\end{split}" text="R@=@A@R@PUNCT@A@[@i@,@j@]@[@u@,@v@]@=@{@matrix[[1 / (absolute-value@(N * u) * absolute-value@(N * v)), [if ∈(i,u)E1 and ∈(j,v)E2,]], [0, [otherwise.]]]" fragid="S2.E2.m1">
          <XMath>
            <XMDual>
              <XMWrap rule="Anything,">
                <XMRef idref="S2.E2.m1.1"/>
                <XMRef idref="S2.E2.m1.2"/>
                <XMRef idref="S2.E2.m1.3"/>
                <XMRef idref="S2.E2.m1.4"/>
                <XMTok role="PUNCT"/>
                <XMRef idref="S2.E2.m1.6"/>
                <XMWrap>
                  <XMRef idref="S2.E2.m1.7"/>
                  <XMRef idref="S2.E2.m1.8"/>
                  <XMRef idref="S2.E2.m1.9"/>
                  <XMRef idref="S2.E2.m1.10"/>
                  <XMRef idref="S2.E2.m1.11"/>
                </XMWrap>
                <XMWrap>
                  <XMRef idref="S2.E2.m1.12"/>
                  <XMRef idref="S2.E2.m1.13"/>
                  <XMRef idref="S2.E2.m1.14"/>
                  <XMRef idref="S2.E2.m1.15"/>
                  <XMRef idref="S2.E2.m1.16"/>
                </XMWrap>
                <XMRef idref="S2.E2.m1.17"/>
                <XMWrap>
                  <XMRef idref="S2.E2.m1.18"/>
                  <XMRef idref="S2.E2.m1.19"/>
                </XMWrap>
              </XMWrap>
              <XMArray name="aligned">
                <XMRow>
                  <XMCell align="right">
                    <XMTok role="UNKNOWN" xml:id="S2.E2.m1.1" font="italic" fragid="S2.E2.m1.1">R</XMTok>
                  </XMCell>
                  <XMCell align="left">
                    <XMApp punctuation=",">
                      <XMTok meaning="equals" role="RELOP" xml:id="S2.E2.m1.2" fragid="S2.E2.m1.2">=</XMTok>
                      <XMTok meaning="absent"/>
                      <XMApp>
                        <XMTok meaning="times" role="MULOP">⁢</XMTok>
                        <XMTok role="UNKNOWN" xml:id="S2.E2.m1.3" font="italic" fragid="S2.E2.m1.3">A</XMTok>
                        <XMTok role="UNKNOWN" xml:id="S2.E2.m1.4" font="italic" fragid="S2.E2.m1.4">R</XMTok>
                      </XMApp>
                    </XMApp>
                  </XMCell>
                </XMRow>
                <XMRow>
                  <XMCell align="right">
                    <XMApp>
                      <XMTok meaning="times" role="MULOP">⁢</XMTok>
                      <XMTok role="UNKNOWN" xml:id="S2.E2.m1.6" font="italic" fragid="S2.E2.m1.6">A</XMTok>
                      <XMWrap>
                        <XMTok role="OPEN" stretchy="false" xml:id="S2.E2.m1.7" fragid="S2.E2.m1.7">[</XMTok>
                        <XMTok role="UNKNOWN" xml:id="S2.E2.m1.8" font="italic" fragid="S2.E2.m1.8">i</XMTok>
                        <XMTok role="PUNCT" xml:id="S2.E2.m1.9" fragid="S2.E2.m1.9">,</XMTok>
                        <XMTok role="UNKNOWN" xml:id="S2.E2.m1.10" font="italic" fragid="S2.E2.m1.10">j</XMTok>
                        <XMTok role="CLOSE" stretchy="false" xml:id="S2.E2.m1.11" fragid="S2.E2.m1.11">]</XMTok>
                      </XMWrap>
                      <XMWrap>
                        <XMTok role="OPEN" stretchy="false" xml:id="S2.E2.m1.12" fragid="S2.E2.m1.12">[</XMTok>
                        <XMTok role="UNKNOWN" xml:id="S2.E2.m1.13" font="italic" fragid="S2.E2.m1.13">u</XMTok>
                        <XMTok role="PUNCT" xml:id="S2.E2.m1.14" fragid="S2.E2.m1.14">,</XMTok>
                        <XMTok role="UNKNOWN" xml:id="S2.E2.m1.15" font="italic" fragid="S2.E2.m1.15">v</XMTok>
                        <XMTok role="CLOSE" stretchy="false" xml:id="S2.E2.m1.16" fragid="S2.E2.m1.16">]</XMTok>
                      </XMWrap>
                    </XMApp>
                  </XMCell>
                  <XMCell align="left">
                    <XMArg rule="Anything,">
                      <XMTok meaning="equals" role="RELOP" xml:id="S2.E2.m1.17" fragid="S2.E2.m1.17">=</XMTok>
                      <XMWrap>
                        <XMTok role="OPEN" stretchy="false" xml:id="S2.E2.m1.18" fontsize="160%" fragid="S2.E2.m1.18">{</XMTok>
                        <XMArray meaning="matrix" xml:id="S2.E2.m1.19" fragid="S2.E2.m1.19">
                          <XMRow>
                            <XMCell align="center">
                              <XMApp>
                                <XMTok mathstyle="text" meaning="divide" role="MULOP"/>
                                <XMTok meaning="1" role="NUMBER">1</XMTok>
                                <XMApp>
                                  <XMTok meaning="times" role="MULOP">⁢</XMTok>
                                  <XMDual>
                                    <XMApp>
                                      <XMTok meaning="absolute-value"/>
                                      <XMRef idref="S2.E2.m1.19.3"/>
                                    </XMApp>
                                    <XMWrap>
                                      <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                      <XMApp xml:id="S2.E2.m1.19.3" fragid="S2.E2.m1.19.3">
                                        <XMTok meaning="times" role="MULOP">⁢</XMTok>
                                        <XMTok role="UNKNOWN" font="italic">N</XMTok>
                                        <XMDual>
                                          <XMRef idref="S2.E2.m1.19.1"/>
                                          <XMWrap>
                                            <XMTok role="OPEN" stretchy="false">(</XMTok>
                                            <XMTok role="UNKNOWN" xml:id="S2.E2.m1.19.1" font="italic" fragid="S2.E2.m1.19.1">u</XMTok>
                                            <XMTok role="CLOSE" stretchy="false">)</XMTok>
                                          </XMWrap>
                                        </XMDual>
                                      </XMApp>
                                      <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                    </XMWrap>
                                  </XMDual>
                                  <XMDual>
                                    <XMApp>
                                      <XMTok meaning="absolute-value"/>
                                      <XMRef idref="S2.E2.m1.19.4"/>
                                    </XMApp>
                                    <XMWrap>
                                      <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                      <XMApp xml:id="S2.E2.m1.19.4" fragid="S2.E2.m1.19.4">
                                        <XMTok meaning="times" role="MULOP">⁢</XMTok>
                                        <XMTok role="UNKNOWN" font="italic">N</XMTok>
                                        <XMDual>
                                          <XMRef idref="S2.E2.m1.19.2"/>
                                          <XMWrap>
                                            <XMTok role="OPEN" stretchy="false">(</XMTok>
                                            <XMTok role="UNKNOWN" xml:id="S2.E2.m1.19.2" font="italic" fragid="S2.E2.m1.19.2">v</XMTok>
                                            <XMTok role="CLOSE" stretchy="false">)</XMTok>
                                          </XMWrap>
                                        </XMDual>
                                      </XMApp>
                                      <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                    </XMWrap>
                                  </XMDual>
                                </XMApp>
                              </XMApp>
                            </XMCell>
                            <XMCell align="center">
                              <XMText>if <Math mode="inline" tex="(i,u)\in E_{1}" text="open-interval@(i, u) element-of E _ 1" xml:id="S2.E2.m1.m1" fragid="S2.E2.m1.m1"><XMath><XMApp><XMTok meaning="element-of" name="in" role="RELOP">∈</XMTok><XMDual><XMApp><XMTok meaning="open-interval"/><XMRef idref="S2.E2.m1.m1.1"/><XMRef idref="S2.E2.m1.m1.2"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMTok role="UNKNOWN" xml:id="S2.E2.m1.m1.1" font="italic" fragid="S2.E2.m1.m1.1">i</XMTok><XMTok role="PUNCT">,</XMTok><XMTok role="UNKNOWN" xml:id="S2.E2.m1.m1.2" font="italic" fragid="S2.E2.m1.m1.2">u</XMTok><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post14"/><XMTok role="UNKNOWN" font="italic">E</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMath></Math> and <Math mode="inline" tex="(j,v)\in E_{2}" text="open-interval@(j, v) element-of E _ 2" xml:id="S2.E2.m1.m2" fragid="S2.E2.m1.m2"><XMath><XMApp><XMTok meaning="element-of" name="in" role="RELOP">∈</XMTok><XMDual><XMApp><XMTok meaning="open-interval"/><XMRef idref="S2.E2.m1.m2.1"/><XMRef idref="S2.E2.m1.m2.2"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMTok role="UNKNOWN" xml:id="S2.E2.m1.m2.1" font="italic" fragid="S2.E2.m1.m2.1">j</XMTok><XMTok role="PUNCT">,</XMTok><XMTok role="UNKNOWN" xml:id="S2.E2.m1.m2.2" font="italic" fragid="S2.E2.m1.m2.2">v</XMTok><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post14"/><XMTok role="UNKNOWN" font="italic">E</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMath></Math>,</XMText>
                            </XMCell>
                          </XMRow>
                          <XMRow>
                            <XMCell align="center">
                              <XMTok meaning="0" role="NUMBER">0</XMTok>
                            </XMCell>
                            <XMCell align="center">
                              <XMText>otherwise.</XMText>
                            </XMCell>
                          </XMRow>
                        </XMArray>
                      </XMWrap>
                    </XMArg>
                  </XMCell>
                </XMRow>
              </XMArray>
            </XMDual>
          </XMath>
        </Math>
      </equation>
      <p>In the above equation, <Math mode="inline" xml:id="S2.p2.m1" tex="A" text="A" fragid="S2.p2.m1"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> is a <Math mode="inline" xml:id="S2.p2.m2" tex="|V_{1}||V_{2}|" text="absolute-value@(V _ 1) * absolute-value@(V _ 2)" fragid="S2.p2.m2"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S2.p2.m2.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S2.p2.m2.1" fragid="S2.p2.m2.1"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S2.p2.m2.2"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S2.p2.m2.2" fragid="S2.p2.m2.2"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual></XMApp></XMath></Math>x<Math mode="inline" xml:id="S2.p2.m3" tex="|V_{1}||V_{2}|" text="absolute-value@(V _ 1) * absolute-value@(V _ 2)" fragid="S2.p2.m3"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S2.p2.m3.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S2.p2.m3.1" fragid="S2.p2.m3.1"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S2.p2.m3.2"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S2.p2.m3.2" fragid="S2.p2.m3.2"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual></XMApp></XMath></Math> stochastic matrix and can be defined from the Kronecker product of the normalized adjacency matrices of the input graphs:
<Math mode="inline" xml:id="S2.p2.m4" tex="A=A_{1}\otimes A_{2}" text="A = A _ 1 tensor-product A _ 2" fragid="S2.p2.m4"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok meaning="tensor-product" name="otimes" role="MULOP">⊗</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp></XMath></Math>, where <Math mode="inline" xml:id="S2.p2.m5" tex="A_{i}" text="A _ i" fragid="S2.p2.m5"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math> is the normalized adjacency
matrix for the graph <Math mode="inline" xml:id="S2.p2.m6" tex="G_{i}" text="G _ i" fragid="S2.p2.m6"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math> and also a stochastic matrix.
Eq.(<ref labelref="LABEL:Eq:IsoRank1" href="#S2.E2" title="(2) ‣ 2 Classical IsoRank ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">2</text></ref>) describes an eigenvalue problem where the principal eigenvector corresponding to the eigenvalue one of the matrix <Math mode="inline" xml:id="S2.p2.m7" tex="A" text="A" fragid="S2.p2.m7"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> is the stationary distribution of the
random walk on the Kronecker product graph.
On classical computers, this equation can be solved
by using different iterative methods such as the power iteration.</p>
    </para>
  </section>
  <section refnum="3" xml:id="S3" fragid="S3">
    <title><tag close=" ">3</tag>Quantum Phase Estimation Algorithm for Network Alignment</title>
    <para xml:id="S3.p1" fragid="S3.p1">
      <p>In this section, we briefly explain the main intuition of the quantum phase estimation algorithm after giving a very small introduction to quantum computing.
For a comprehensive introduction on quantum computing, we strongly recommend the reader to go through the first chapters of ref.<cite class="ltx_citemacro_cite">[<ref href="#bib.bibx13" idref="bib.bibx13">Nielsen and Chuang(2010)</ref>]</cite>.</p>
    </para>
    <subsection refnum="3.1" xml:id="S3.SS1" fragid="S3.SS1">
      <title><tag close=" ">3.1</tag>Quantum Computing</title>
      <para xml:id="S3.SS1.p1" fragid="S3.SS1.p1">
        <p>Quantum computers use <Math mode="inline" xml:id="S3.SS1.p1.m1" tex="\left|0\right\rangle" text="ket@(0)" fragid="S3.SS1.p1.m1"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m1.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok meaning="0" role="NUMBER" xml:id="S3.SS1.p1.m1.1" fragid="S3.SS1.p1.m1.1">0</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> and <Math mode="inline" xml:id="S3.SS1.p1.m2" tex="\left|1\right\rangle" text="ket@(1)" fragid="S3.SS1.p1.m2"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m2.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok meaning="1" role="NUMBER" xml:id="S3.SS1.p1.m2.1" fragid="S3.SS1.p1.m2.1">1</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> vectors in Dirac notation to represent information. These two vectors are associated with two distinguishable states of a quantum system, a <text font="italic">qubit</text>, and defines a basis set. In general, the state of the system, <Math mode="inline" xml:id="S3.SS1.p1.m3" tex="\left|\psi\right\rangle" text="ket@(psi)" fragid="S3.SS1.p1.m3"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m3.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok name="psi" role="UNKNOWN" xml:id="S3.SS1.p1.m3.1" font="italic" fragid="S3.SS1.p1.m3.1">ψ</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, can be in <text font="italic">superposition</text> of these states with normalized complex amplitudes (coefficients) <Math mode="inline" xml:id="S3.SS1.p1.m4" tex="\alpha_{0}" text="alpha _ 0" fragid="S3.SS1.p1.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok><XMTok meaning="0" role="NUMBER">0</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S3.SS1.p1.m5" tex="\alpha_{1}" text="alpha _ 1" fragid="S3.SS1.p1.m5"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math>:
<!-- %**** ppi-main.tex Line 125 **** --></p>
        <equation frefnum="(3)" refnum="3" xml:id="S3.E3" fragid="S3.E3">
          <Math mode="display" xml:id="S3.E3.m1" tex="\left|\psi\right\rangle=\alpha_{0}\left|0\right\rangle+\alpha_{1}\left|1\right\rangle." text="ket@(psi) = alpha _ 0 * ket@(0) + alpha _ 1 * ket@(1)" fragid="S3.E3.m1">
            <XMath>
              <XMApp punctuation=".">
                <XMTok meaning="equals" role="RELOP">=</XMTok>
                <XMDual>
                  <XMApp>
                    <XMTok meaning="ket"/>
                    <XMRef idref="S3.E3.m1.1"/>
                  </XMApp>
                  <XMWrap>
                    <XMTok role="OPEN">|</XMTok>
                    <XMTok name="psi" role="UNKNOWN" xml:id="S3.E3.m1.1" font="italic" fragid="S3.E3.m1.1">ψ</XMTok>
                    <XMTok name="rangle" role="CLOSE">⟩</XMTok>
                  </XMWrap>
                </XMDual>
                <XMApp>
                  <XMTok meaning="plus" role="ADDOP">+</XMTok>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                      <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                      <XMTok meaning="0" role="NUMBER">0</XMTok>
                    </XMApp>
                    <XMDual>
                      <XMApp>
                        <XMTok meaning="ket"/>
                        <XMRef idref="S3.E3.m1.2"/>
                      </XMApp>
                      <XMWrap>
                        <XMTok role="OPEN">|</XMTok>
                        <XMTok meaning="0" role="NUMBER" xml:id="S3.E3.m1.2" fragid="S3.E3.m1.2">0</XMTok>
                        <XMTok name="rangle" role="CLOSE">⟩</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                      <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                      <XMTok meaning="1" role="NUMBER">1</XMTok>
                    </XMApp>
                    <XMDual>
                      <XMApp>
                        <XMTok meaning="ket"/>
                        <XMRef idref="S3.E3.m1.3"/>
                      </XMApp>
                      <XMWrap>
                        <XMTok role="OPEN">|</XMTok>
                        <XMTok meaning="1" role="NUMBER" xml:id="S3.E3.m1.3" fragid="S3.E3.m1.3">1</XMTok>
                        <XMTok name="rangle" role="CLOSE">⟩</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                </XMApp>
              </XMApp>
            </XMath>
          </Math>
        </equation>
        <p><Math mode="inline" xml:id="S3.SS1.p1.m6" tex="\left|\psi\right\rangle" text="ket@(psi)" fragid="S3.SS1.p1.m6"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m6.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok name="psi" role="UNKNOWN" xml:id="S3.SS1.p1.m6.1" font="italic" fragid="S3.SS1.p1.m6.1">ψ</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> describes one bit information. In order to know the information carried on the qubit, we apply a measurement to the system in the basis <Math mode="inline" xml:id="S3.SS1.p1.m7" tex="\left|0\right\rangle" text="ket@(0)" fragid="S3.SS1.p1.m7"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m7.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok meaning="0" role="NUMBER" xml:id="S3.SS1.p1.m7.1" fragid="S3.SS1.p1.m7.1">0</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> and <Math mode="inline" xml:id="S3.SS1.p1.m8" tex="\left|1\right\rangle" text="ket@(1)" fragid="S3.SS1.p1.m8"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m8.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok meaning="1" role="NUMBER" xml:id="S3.SS1.p1.m8.1" fragid="S3.SS1.p1.m8.1">1</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>.
In quantum mechanics, it is known that this measurement outcomes either 0 or 1 with probabilities <Math mode="inline" xml:id="S3.SS1.p1.m9" tex="|\alpha_{0}|^{2}" text="(absolute-value@(alpha _ 0)) ^ 2" fragid="S3.SS1.p1.m9"><XMath><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S3.SS1.p1.m9.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S3.SS1.p1.m9.1" fragid="S3.SS1.p1.m9.1"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok><XMTok meaning="0" role="NUMBER">0</XMTok></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S3.SS1.p1.m10" tex="|\alpha_{1}|^{2}" text="(absolute-value@(alpha _ 1)) ^ 2" fragid="S3.SS1.p1.m10"><XMath><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S3.SS1.p1.m10.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S3.SS1.p1.m10.1" fragid="S3.SS1.p1.m10.1"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>, respectively.
The number of states grows exponentially with the number of qubits involved in the system. Thus, if two qubits are considered, then there are four distinguishable states of the system, viz. <Math mode="inline" xml:id="S3.SS1.p1.m11" tex="\left|00\right\rangle" text="ket@(00)" fragid="S3.SS1.p1.m11"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m11.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok meaning="00" role="NUMBER" xml:id="S3.SS1.p1.m11.1" fragid="S3.SS1.p1.m11.1">00</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, <Math mode="inline" xml:id="S3.SS1.p1.m12" tex="\left|01\right\rangle" text="ket@(01)" fragid="S3.SS1.p1.m12"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m12.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok meaning="01" role="NUMBER" xml:id="S3.SS1.p1.m12.1" fragid="S3.SS1.p1.m12.1">01</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, <Math mode="inline" xml:id="S3.SS1.p1.m13" tex="\left|10\right\rangle" text="ket@(10)" fragid="S3.SS1.p1.m13"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m13.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok meaning="10" role="NUMBER" xml:id="S3.SS1.p1.m13.1" fragid="S3.SS1.p1.m13.1">10</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, and <Math mode="inline" xml:id="S3.SS1.p1.m14" tex="\left|11\right\rangle" text="ket@(11)" fragid="S3.SS1.p1.m14"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m14.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok meaning="11" role="NUMBER" xml:id="S3.SS1.p1.m14.1" fragid="S3.SS1.p1.m14.1">11</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, which is again used as a basis set to describe the state of the system in superposition:</p>
        <equation frefnum="(4)" refnum="4" xml:id="S3.E4" fragid="S3.E4">
          <Math mode="display" xml:id="S3.E4.m1" tex="\left|\psi\right\rangle=\alpha_{0}\left|00\right\rangle+\alpha_{1}\left|01%&#10;\right\rangle+\alpha_{2}\left|10\right\rangle+\alpha_{3}\left|11\right\rangle," text="ket@(psi) = alpha _ 0 * ket@(00) + alpha _ 1 * ket@(01) + alpha _ 2 * ket@(10) + alpha _ 3 * ket@(11)" fragid="S3.E4.m1">
            <XMath>
              <XMApp punctuation=",">
                <XMTok meaning="equals" role="RELOP">=</XMTok>
                <XMDual>
                  <XMApp>
                    <XMTok meaning="ket"/>
                    <XMRef idref="S3.E4.m1.1"/>
                  </XMApp>
                  <XMWrap>
                    <XMTok role="OPEN">|</XMTok>
                    <XMTok name="psi" role="UNKNOWN" xml:id="S3.E4.m1.1" font="italic" fragid="S3.E4.m1.1">ψ</XMTok>
                    <XMTok name="rangle" role="CLOSE">⟩</XMTok>
                  </XMWrap>
                </XMDual>
                <XMApp>
                  <XMTok meaning="plus" role="ADDOP">+</XMTok>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                      <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                      <XMTok meaning="0" role="NUMBER">0</XMTok>
                    </XMApp>
                    <XMDual>
                      <XMApp>
                        <XMTok meaning="ket"/>
                        <XMRef idref="S3.E4.m1.2"/>
                      </XMApp>
                      <XMWrap>
                        <XMTok role="OPEN">|</XMTok>
                        <XMTok meaning="00" role="NUMBER" xml:id="S3.E4.m1.2" fragid="S3.E4.m1.2">00</XMTok>
                        <XMTok name="rangle" role="CLOSE">⟩</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                      <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                      <XMTok meaning="1" role="NUMBER">1</XMTok>
                    </XMApp>
                    <XMDual>
                      <XMApp>
                        <XMTok meaning="ket"/>
                        <XMRef idref="S3.E4.m1.3"/>
                      </XMApp>
                      <XMWrap>
                        <XMTok role="OPEN">|</XMTok>
                        <XMTok meaning="01" role="NUMBER" xml:id="S3.E4.m1.3" fragid="S3.E4.m1.3">01</XMTok>
                        <XMTok name="rangle" role="CLOSE">⟩</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                      <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                      <XMTok meaning="2" role="NUMBER">2</XMTok>
                    </XMApp>
                    <XMDual>
                      <XMApp>
                        <XMTok meaning="ket"/>
                        <XMRef idref="S3.E4.m1.4"/>
                      </XMApp>
                      <XMWrap>
                        <XMTok role="OPEN">|</XMTok>
                        <XMTok meaning="10" role="NUMBER" xml:id="S3.E4.m1.4" fragid="S3.E4.m1.4">10</XMTok>
                        <XMTok name="rangle" role="CLOSE">⟩</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                      <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                      <XMTok meaning="3" role="NUMBER">3</XMTok>
                    </XMApp>
                    <XMDual>
                      <XMApp>
                        <XMTok meaning="ket"/>
                        <XMRef idref="S3.E4.m1.5"/>
                      </XMApp>
                      <XMWrap>
                        <XMTok role="OPEN">|</XMTok>
                        <XMTok meaning="11" role="NUMBER" xml:id="S3.E4.m1.5" fragid="S3.E4.m1.5">11</XMTok>
                        <XMTok name="rangle" role="CLOSE">⟩</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                </XMApp>
              </XMApp>
            </XMath>
          </Math>
        </equation>
        <p>where <Math mode="inline" xml:id="S3.SS1.p1.m15" tex="|\alpha_{i}|^{2}" text="(absolute-value@(alpha _ i)) ^ 2" fragid="S3.SS1.p1.m15"><XMath><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S3.SS1.p1.m15.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S3.SS1.p1.m15.1" fragid="S3.SS1.p1.m15.1"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> is the probability to see the system in <Math mode="inline" xml:id="S3.SS1.p1.m16" tex="\left|\bm{i}\right\rangle" text="ket@(i)" fragid="S3.SS1.p1.m16"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS1.p1.m16.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok role="UNKNOWN" xml:id="S3.SS1.p1.m16.1" font="bold italic" fragid="S3.SS1.p1.m16.1">i</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> state after a measurement.
To change the state of the system, different quantum operations can be applied.
If the amplitudes are represented in vector form, then all of these operations can be described as a matrix-vector transformation:</p>
        <equation frefnum="(5)" refnum="5" xml:id="S3.E5" fragid="S3.E5">
          <Math mode="display" xml:id="S3.E5.m1" tex="U\begin{vmatrix}\alpha_{0}\\&#10;\alpha_{1}\\&#10;\alpha_{2}\\&#10;\alpha_{3}\\&#10;\end{vmatrix}=\begin{vmatrix}\tilde{\alpha}_{0}\\&#10;\tilde{\alpha}_{1}\\&#10;\tilde{\alpha}_{2}\\&#10;\tilde{\alpha}_{3}\\&#10;\end{vmatrix}," text="U * determinant@(matrix[[alpha _ 0], [alpha _ 1], [alpha _ 2], [alpha _ 3]]) = determinant@(matrix[[(tilde@(alpha)) _ 0], [(tilde@(alpha)) _ 1], [(tilde@(alpha)) _ 2], [(tilde@(alpha)) _ 3]])" fragid="S3.E5.m1">
            <XMath>
              <XMApp punctuation=",">
                <XMTok meaning="equals" role="RELOP">=</XMTok>
                <XMApp>
                  <XMTok meaning="times" role="MULOP">⁢</XMTok>
                  <XMTok role="UNKNOWN" font="italic">U</XMTok>
                  <XMDual>
                    <XMApp>
                      <XMTok meaning="determinant"/>
                      <XMRef idref="S3.E5.m1.1"/>
                    </XMApp>
                    <XMWrap>
                      <XMTok role="VERTBAR">|</XMTok>
                      <XMArray meaning="matrix" xml:id="S3.E5.m1.1" fragid="S3.E5.m1.1">
                        <XMRow>
                          <XMCell align="center">
                            <XMApp>
                              <XMTok role="SUBSCRIPTOP" scriptpos="post7"/>
                              <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                              <XMTok meaning="0" role="NUMBER">0</XMTok>
                            </XMApp>
                          </XMCell>
                        </XMRow>
                        <XMRow>
                          <XMCell align="center">
                            <XMApp>
                              <XMTok role="SUBSCRIPTOP" scriptpos="post7"/>
                              <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                              <XMTok meaning="1" role="NUMBER">1</XMTok>
                            </XMApp>
                          </XMCell>
                        </XMRow>
                        <XMRow>
                          <XMCell align="center">
                            <XMApp>
                              <XMTok role="SUBSCRIPTOP" scriptpos="post7"/>
                              <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                              <XMTok meaning="2" role="NUMBER">2</XMTok>
                            </XMApp>
                          </XMCell>
                        </XMRow>
                        <XMRow>
                          <XMCell align="center">
                            <XMApp>
                              <XMTok role="SUBSCRIPTOP" scriptpos="post7"/>
                              <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                              <XMTok meaning="3" role="NUMBER">3</XMTok>
                            </XMApp>
                          </XMCell>
                        </XMRow>
                      </XMArray>
                      <XMTok role="VERTBAR">|</XMTok>
                    </XMWrap>
                  </XMDual>
                </XMApp>
                <XMDual>
                  <XMApp>
                    <XMTok meaning="determinant"/>
                    <XMRef idref="S3.E5.m1.2"/>
                  </XMApp>
                  <XMWrap>
                    <XMTok role="VERTBAR">|</XMTok>
                    <XMArray meaning="matrix" xml:id="S3.E5.m1.2" fragid="S3.E5.m1.2">
                      <XMRow>
                        <XMCell align="center">
                          <XMApp>
                            <XMTok role="SUBSCRIPTOP" scriptpos="post7"/>
                            <XMApp>
                              <XMTok name="tilde" role="OVERACCENT" stretchy="false">~</XMTok>
                              <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                            </XMApp>
                            <XMTok meaning="0" role="NUMBER">0</XMTok>
                          </XMApp>
                        </XMCell>
                      </XMRow>
                      <XMRow>
                        <XMCell align="center">
                          <XMApp>
                            <XMTok role="SUBSCRIPTOP" scriptpos="post7"/>
                            <XMApp>
                              <XMTok name="tilde" role="OVERACCENT" stretchy="false">~</XMTok>
                              <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                            </XMApp>
                            <XMTok meaning="1" role="NUMBER">1</XMTok>
                          </XMApp>
                        </XMCell>
                      </XMRow>
                      <XMRow>
                        <XMCell align="center">
                          <XMApp>
                            <XMTok role="SUBSCRIPTOP" scriptpos="post7"/>
                            <XMApp>
                              <XMTok name="tilde" role="OVERACCENT" stretchy="false">~</XMTok>
                              <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                            </XMApp>
                            <XMTok meaning="2" role="NUMBER">2</XMTok>
                          </XMApp>
                        </XMCell>
                      </XMRow>
                      <XMRow>
                        <XMCell align="center">
                          <XMApp>
                            <XMTok role="SUBSCRIPTOP" scriptpos="post7"/>
                            <XMApp>
                              <XMTok name="tilde" role="OVERACCENT" stretchy="false">~</XMTok>
                              <XMTok name="alpha" role="UNKNOWN" font="italic">α</XMTok>
                            </XMApp>
                            <XMTok meaning="3" role="NUMBER">3</XMTok>
                          </XMApp>
                        </XMCell>
                      </XMRow>
                    </XMArray>
                    <XMTok role="VERTBAR">|</XMTok>
                  </XMWrap>
                </XMDual>
              </XMApp>
            </XMath>
          </Math>
        </equation>
        <!-- %**** ppi-main.tex Line 150 **** -->
        <p>where <Math mode="inline" xml:id="S3.SS1.p1.m17" tex="U" text="U" fragid="S3.SS1.p1.m17"><XMath><XMTok role="UNKNOWN" font="italic">U</XMTok></XMath></Math> is a 4x4 unitary matrix describing a quantum operation.
Engineering the matrix elements of <Math mode="inline" xml:id="S3.SS1.p1.m18" tex="U" text="U" fragid="S3.SS1.p1.m18"><XMath><XMTok role="UNKNOWN" font="italic">U</XMTok></XMath></Math> and benefiting from the quantum superposition and other phenomena, many efficient quantum algorithms are proposed such as the Shor’s integer factoring algorithm <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx14" idref="bib.bibx14">Shor(1994)</ref>]</cite>, Grover’s search algorithm <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx15" idref="bib.bibx15">Grover(1996)</ref>]</cite> and the quantum phase estimation algorithm <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx16" idref="bib.bibx16">Kitaev(1995)</ref>]</cite> which is of interest in this paper and described in more detail in the following section.</p>
      </para>
    </subsection>
    <subsection refnum="3.2" xml:id="S3.SS2" fragid="S3.SS2">
      <title><tag close=" ">3.2</tag>Quantum Phase Estimation Algorithm</title>
      <para xml:id="S3.SS2.p1" fragid="S3.SS2.p1">
        <p>For a given approximate eigenvector encoded as the amplitudes of the quantum state <Math mode="inline" xml:id="S3.SS2.p1.m1" tex="\left|\mu_{j}\right\rangle" text="ket@(mu _ j)" fragid="S3.SS2.p1.m1"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m1.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m1.1" fragid="S3.SS2.p1.m1.1"><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok name="mu" role="UNKNOWN" font="italic">μ</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>
and the eigenvalue equation <Math mode="inline" xml:id="S3.SS2.p1.m2" tex="U\left|\mu_{j}\right\rangle=e^{i2\pi\phi_{j}}\left|\mu_{j}\right\rangle" text="U * ket@(mu _ j) = e ^ (i * 2 * pi * phi _ j) * ket@(mu _ j)" fragid="S3.SS2.p1.m2"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">U</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m2.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m2.1" fragid="S3.SS2.p1.m2.1"><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok name="mu" role="UNKNOWN" font="italic">μ</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMApp><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok><XMTok name="pi" role="UNKNOWN" font="italic">π</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok name="phi" role="UNKNOWN" font="italic">ϕ</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMApp></XMApp><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m2.2"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m2.2" fragid="S3.SS2.p1.m2.2"><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok name="mu" role="UNKNOWN" font="italic">μ</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMApp></XMApp></XMath></Math>; the phase estimation algorithm (PEA) tries to find the phase <Math mode="inline" xml:id="S3.SS2.p1.m3" tex="\phi_{j}" text="phi _ j" fragid="S3.SS2.p1.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok name="phi" role="UNKNOWN" font="italic">ϕ</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math> in this equation.
PEA mainly requires two quantum registers, <Math mode="inline" xml:id="S3.SS2.p1.m4" tex="\left|reg_{1}\right\rangle" text="ket@(r * e * g _ 1)" fragid="S3.SS2.p1.m4"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m4.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m4.1" fragid="S3.SS2.p1.m4.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> and <Math mode="inline" xml:id="S3.SS2.p1.m5" tex="\left|reg_{2}\right\rangle" text="ket@(r * e * g _ 2)" fragid="S3.SS2.p1.m5"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m5.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m5.1" fragid="S3.SS2.p1.m5.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, consisting of sufficient number of qubits to hold the eigenvector and the phase, respectively.
In the initial setting, <Math mode="inline" xml:id="S3.SS2.p1.m6" tex="\left|reg1\right\rangle" text="ket@(r * e * g * 1)" fragid="S3.SS2.p1.m6"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m6.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m6.1" fragid="S3.SS2.p1.m6.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> is set to zero state and <Math mode="inline" xml:id="S3.SS2.p1.m7" tex="\left|reg_{2}\right\rangle" text="ket@(r * e * g _ 2)" fragid="S3.SS2.p1.m7"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m7.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m7.1" fragid="S3.SS2.p1.m7.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> is assigned to hold a vector which is the best known approximation of <Math mode="inline" xml:id="S3.SS2.p1.m8" tex="\left|\mu_{j}\right\rangle" text="ket@(mu _ j)" fragid="S3.SS2.p1.m8"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m8.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m8.1" fragid="S3.SS2.p1.m8.1"><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok name="mu" role="UNKNOWN" font="italic">μ</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>.
With the help of quantum Fourier transform (please see Appendix <ref labelref="LABEL:appendix:QFT" href="#A1" title="Appendix A Quantum Fourier Transform ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">A</text></ref> for the description of the quantum Fourier transform)
and the sequential controlled unitary operations, <Math mode="inline" xml:id="S3.SS2.p1.m9" tex="\left|reg_{1}\right\rangle" text="ket@(r * e * g _ 1)" fragid="S3.SS2.p1.m9"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m9.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m9.1" fragid="S3.SS2.p1.m9.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> becomes holding the Fourier transform of the phase.
Then, the application of the inverse quantum Fourier transform turns <Math mode="inline" xml:id="S3.SS2.p1.m10" tex="\left|reg1\right\rangle" text="ket@(r * e * g * 1)" fragid="S3.SS2.p1.m10"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m10.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m10.1" fragid="S3.SS2.p1.m10.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> into the binary value of the phase: <Math mode="inline" xml:id="S3.SS2.p1.m11" tex="\left|reg1\right\rangle=\left|\phi_{j}\right\rangle" text="ket@(r * e * g * 1) = ket@(phi _ j)" fragid="S3.SS2.p1.m11"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m11.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m11.1" fragid="S3.SS2.p1.m11.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m11.2"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m11.2" fragid="S3.SS2.p1.m11.2"><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok name="phi" role="UNKNOWN" font="italic">ϕ</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMApp></XMath></Math>.
Consequently, the value of the phase is obtained by measuring <Math mode="inline" xml:id="S3.SS2.p1.m12" tex="\left|reg1\right\rangle" text="ket@(r * e * g * 1)" fragid="S3.SS2.p1.m12"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S3.SS2.p1.m12.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S3.SS2.p1.m12.1" fragid="S3.SS2.p1.m12.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> in the standard basis.
Here, if the unitary operator <Math mode="inline" xml:id="S3.SS2.p1.m13" tex="U" text="U" fragid="S3.SS2.p1.m13"><XMath><XMTok role="UNKNOWN" font="italic">U</XMTok></XMath></Math> is the time evolution operator of a Hermitian matrix <Math mode="inline" xml:id="S3.SS2.p1.m14" tex="H" text="H" fragid="S3.SS2.p1.m14"><XMath><XMTok role="UNKNOWN" font="italic">H</XMTok></XMath></Math>, <Math mode="inline" xml:id="S3.SS2.p1.m15" tex="U=e^{i2\pi H}" text="U = e ^ (i * 2 * pi * H)" fragid="S3.SS2.p1.m15"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">U</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok><XMTok name="pi" role="UNKNOWN" font="italic">π</XMTok><XMTok role="UNKNOWN" font="italic">H</XMTok></XMApp></XMApp></XMApp></XMath></Math>,
then one also obtains the eigenvalue of <Math mode="inline" xml:id="S3.SS2.p1.m16" tex="H" text="H" fragid="S3.SS2.p1.m16"><XMath><XMTok role="UNKNOWN" font="italic">H</XMTok></XMath></Math>.</p>
      </para>
    </subsection>
    <subsection refnum="3.3" xml:id="S3.SS3" fragid="S3.SS3">
      <title><tag close=" ">3.3</tag>Application to Stochastic Matrices</title>
      <para xml:id="S3.SS3.p1" fragid="S3.SS3.p1">
        <p>The success of the phase estimation algorithm is directly related to the closeness of the input vector to the actual eigenvector.
This can be defined by the dot product.
The dot product of an equal superposition state and a vector is the normalized sum of the vector elements.
On the other hand, the eigenvectors of a stochastic matrix has the property that the sum of the vector elements is one for the principal eigenvector and zero for the rest of the eigenvectors.
In ref.<cite class="ltx_citemacro_cite">[<ref href="#bib.bibx12" idref="bib.bibx12">Daskin <emph>et al.</emph>(2014)Daskin,
Grama, and Kais</ref>]</cite>, it has been showed that when PEA is given an equal superposition input state, it then finds the principal eigenvector of <Math mode="inline" xml:id="S3.SS3.p1.m1" tex="U" text="U" fragid="S3.SS3.p1.m1"><XMath><XMTok role="UNKNOWN" font="italic">U</XMTok></XMath></Math> and so the principal eigenvector of the stochastic matrix <Math mode="inline" xml:id="S3.SS3.p1.m2" tex="H" text="H" fragid="S3.SS3.p1.m2"><XMath><XMTok role="UNKNOWN" font="italic">H</XMTok></XMath></Math> with the success probability equal to one.</p>
      </para>
      <para xml:id="S3.SS3.p2" fragid="S3.SS3.p2">
        <p>In our case, we find the principal eigenvector of the matrix <Math mode="inline" xml:id="S3.SS3.p2.m1" tex="A" text="A" fragid="S3.SS3.p2.m1"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> which is the Kronecker product of the normalized adjacency matrices for the input networks: i.e., <Math mode="inline" xml:id="S3.SS3.p2.m2" tex="A=A_{1}\otimes A_{2}\otimes\dots\otimes A_{m}" text="A = A _ 1 tensor-product A _ 2 tensor-product dots tensor-product A _ m" fragid="S3.SS3.p2.m2"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok meaning="tensor-product" name="otimes" role="MULOP">⊗</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMTok name="dots" role="ID">…</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok></XMApp></XMApp></XMApp></XMath></Math>. Because of the Kronecker product, <Math mode="inline" xml:id="S3.SS3.p2.m3" tex="A" text="A" fragid="S3.SS3.p2.m3"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> defines a separable system and so quantum circuits for each <Math mode="inline" xml:id="S3.SS3.p2.m4" tex="A_{i}" text="A _ i" fragid="S3.SS3.p2.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math> can be constructed separately.
This eases the difficulty of finding quantum circuits for the simulation.
<!-- %**** ppi-main.tex Line 175 **** -->However, in general, quantum computing is based on unitary gates associated with time evolution operators of Hermitian quantum systems. This dictates the stochastic matrix used in the algorithm to be Hermitian, in which case the principal eigenvector is already known to be a vector of all ones. In the following subsection, we shall describe how to approach non-Hermitian matrices.</p>
      </para>
    </subsection>
    <subsection refnum="3.4" xml:id="S3.SS4" fragid="S3.SS4">
      <title><tag close=" ">3.4</tag>Simulation of Non-Hermitian Operators</title>
      <para xml:id="S3.SS4.p1" fragid="S3.SS4.p1">
        <p>A matrix <Math mode="inline" xml:id="S3.SS4.p1.m1" tex="A" text="A" fragid="S3.SS4.p1.m1"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> is called positive if the matrix elements
<Math mode="inline" xml:id="S3.SS4.p1.m2" tex="A_{ij}&gt;0" text="A _ (i * j) &gt; 0" fragid="S3.SS4.p1.m2"><XMath><XMApp><XMTok meaning="greater-than" role="RELOP">&gt;</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMApp><XMTok meaning="0" role="NUMBER">0</XMTok></XMApp></XMath></Math> and non-negative if <Math mode="inline" xml:id="S3.SS4.p1.m3" tex="A_{ij}\geq 0" text="A _ (i * j) &gt;= 0" fragid="S3.SS4.p1.m3"><XMath><XMApp><XMTok meaning="greater-than-or-equals" name="geq" role="RELOP">≥</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMApp><XMTok meaning="0" role="NUMBER">0</XMTok></XMApp></XMath></Math>. It is normal if <Math mode="inline" xml:id="S3.SS4.p1.m4" tex="A^{\dagger}A-AA^{\dagger}=0" text="A ^ dagger * A - A * A ^ dagger = 0" fragid="S3.SS4.p1.m4"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMApp><XMTok meaning="minus" role="ADDOP">-</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp><XMTok role="UNKNOWN" font="italic">A</XMTok></XMApp><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp></XMApp></XMApp><XMTok meaning="0" role="NUMBER">0</XMTok></XMApp></XMath></Math>, where <Math mode="inline" xml:id="S3.SS4.p1.m5" tex="A^{\dagger}" text="A ^ dagger" fragid="S3.SS4.p1.m5"><XMath><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp></XMath></Math> describes the conjugate transpose of <Math mode="inline" xml:id="S3.SS4.p1.m6" tex="A" text="A" fragid="S3.SS4.p1.m6"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math>.
Any matrix <Math mode="inline" xml:id="S3.SS4.p1.m7" tex="A" text="A" fragid="S3.SS4.p1.m7"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> can be decomposed into a Hermitian and a skew-Hermitian matrices:</p>
        <equation frefnum="(6)" refnum="6" xml:id="S3.E6" labels="LABEL:EqHSH" fragid="S3.E6">
          <Math mode="display" xml:id="S3.E6.m1" tex="A=H+S=\frac{1}{2}(A+A^{\dagger})+\frac{1}{2}(A-A^{\dagger})," text="A = H + S = (1 / 2) * (A + A ^ dagger) + (1 / 2) * (A - A ^ dagger)" fragid="S3.E6.m1">
            <XMath>
              <XMApp punctuation=",">
                <XMTok meaning="multirelation"/>
                <XMTok role="UNKNOWN" font="italic">A</XMTok>
                <XMTok meaning="equals" role="RELOP">=</XMTok>
                <XMApp>
                  <XMTok meaning="plus" role="ADDOP">+</XMTok>
                  <XMTok role="UNKNOWN" font="italic">H</XMTok>
                  <XMTok role="UNKNOWN" font="italic">S</XMTok>
                </XMApp>
                <XMTok meaning="equals" role="RELOP">=</XMTok>
                <XMApp>
                  <XMTok meaning="plus" role="ADDOP">+</XMTok>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok mathstyle="display" meaning="divide" role="MULOP"/>
                      <XMTok meaning="1" role="NUMBER">1</XMTok>
                      <XMTok meaning="2" role="NUMBER">2</XMTok>
                    </XMApp>
                    <XMDual>
                      <XMRef idref="S3.E6.m1.1"/>
                      <XMWrap>
                        <XMTok role="OPEN" stretchy="false">(</XMTok>
                        <XMApp xml:id="S3.E6.m1.1" fragid="S3.E6.m1.1">
                          <XMTok meaning="plus" role="ADDOP">+</XMTok>
                          <XMTok role="UNKNOWN" font="italic">A</XMTok>
                          <XMApp>
                            <XMTok role="SUPERSCRIPTOP" scriptpos="post2"/>
                            <XMTok role="UNKNOWN" font="italic">A</XMTok>
                            <XMTok name="dagger" role="MULOP">†</XMTok>
                          </XMApp>
                        </XMApp>
                        <XMTok role="CLOSE" stretchy="false">)</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok mathstyle="display" meaning="divide" role="MULOP"/>
                      <XMTok meaning="1" role="NUMBER">1</XMTok>
                      <XMTok meaning="2" role="NUMBER">2</XMTok>
                    </XMApp>
                    <XMDual>
                      <XMRef idref="S3.E6.m1.2"/>
                      <XMWrap>
                        <XMTok role="OPEN" stretchy="false">(</XMTok>
                        <XMApp xml:id="S3.E6.m1.2" fragid="S3.E6.m1.2">
                          <XMTok meaning="minus" role="ADDOP">-</XMTok>
                          <XMTok role="UNKNOWN" font="italic">A</XMTok>
                          <XMApp>
                            <XMTok role="SUPERSCRIPTOP" scriptpos="post2"/>
                            <XMTok role="UNKNOWN" font="italic">A</XMTok>
                            <XMTok name="dagger" role="MULOP">†</XMTok>
                          </XMApp>
                        </XMApp>
                        <XMTok role="CLOSE" stretchy="false">)</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                </XMApp>
              </XMApp>
            </XMath>
          </Math>
        </equation>
        <p>where <Math mode="inline" xml:id="S3.SS4.p1.m8" tex="H=\frac{1}{2}(A+A^{\dagger})" text="H = (1 / 2) * (A + A ^ dagger)" fragid="S3.SS4.p1.m8"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">H</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok mathstyle="text" meaning="divide" role="MULOP"/><XMTok meaning="1" role="NUMBER">1</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMDual><XMRef idref="S3.SS4.p1.m8.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMApp xml:id="S3.SS4.p1.m8.1" fragid="S3.SS4.p1.m8.1"><XMTok meaning="plus" role="ADDOP">+</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp></XMApp><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMApp></XMath></Math> and
<Math mode="inline" xml:id="S3.SS4.p1.m9" tex="S=\frac{1}{2}(A-A^{\dagger})" text="S = (1 / 2) * (A - A ^ dagger)" fragid="S3.SS4.p1.m9"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">S</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok mathstyle="text" meaning="divide" role="MULOP"/><XMTok meaning="1" role="NUMBER">1</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMDual><XMRef idref="S3.SS4.p1.m9.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMApp xml:id="S3.SS4.p1.m9.1" fragid="S3.SS4.p1.m9.1"><XMTok meaning="minus" role="ADDOP">-</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp></XMApp><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMApp></XMath></Math> define the nearest Hermitian and
skew-Hermitian matrices to <Math mode="inline" xml:id="S3.SS4.p1.m10" tex="A" text="A" fragid="S3.SS4.p1.m10"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math>, respectively <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx17" idref="bib.bibx17">Keller(1975)</ref>]</cite>.
The eigenvalues of <Math mode="inline" xml:id="S3.SS4.p1.m11" tex="H" text="H" fragid="S3.SS4.p1.m11"><XMath><XMTok role="UNKNOWN" font="italic">H</XMTok></XMath></Math> are all real and the eigenvalues of <Math mode="inline" xml:id="S3.SS4.p1.m12" tex="S" text="S" fragid="S3.SS4.p1.m12"><XMath><XMTok role="UNKNOWN" font="italic">S</XMTok></XMath></Math> have only imaginary parts. Moreover,
when <Math mode="inline" xml:id="S3.SS4.p1.m13" tex="A" text="A" fragid="S3.SS4.p1.m13"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> is a normal matrix, there are a few additional useful properties:</p>
        <itemize xml:id="I1" fragid="I1">
          <item xml:id="I1.i1" fragid="I1.i1">
            <tag>•</tag>
            <para xml:id="I1.i1.p1" fragid="I1.i1.p1">
              <p><Math mode="inline" xml:id="I1.i1.p1.m1" tex="H" text="H" fragid="I1.i1.p1.m1"><XMath><XMTok role="UNKNOWN" font="italic">H</XMTok></XMath></Math> and <Math mode="inline" xml:id="I1.i1.p1.m2" tex="S" text="S" fragid="I1.i1.p1.m2"><XMath><XMTok role="UNKNOWN" font="italic">S</XMTok></XMath></Math> commute: <Math mode="inline" xml:id="I1.i1.p1.m3" tex="[H,S]=HS-HS=0" text="closed-interval@(H, S) = H * S - H * S = 0" fragid="I1.i1.p1.m3"><XMath><XMApp><XMTok meaning="multirelation"/><XMDual><XMApp><XMTok meaning="closed-interval"/><XMRef idref="I1.i1.p1.m3.1"/><XMRef idref="I1.i1.p1.m3.2"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">[</XMTok><XMTok role="UNKNOWN" xml:id="I1.i1.p1.m3.1" font="italic" fragid="I1.i1.p1.m3.1">H</XMTok><XMTok role="PUNCT">,</XMTok><XMTok role="UNKNOWN" xml:id="I1.i1.p1.m3.2" font="italic" fragid="I1.i1.p1.m3.2">S</XMTok><XMTok role="CLOSE" stretchy="false">]</XMTok></XMWrap></XMDual><XMTok meaning="equals" role="RELOP">=</XMTok><XMApp><XMTok meaning="minus" role="ADDOP">-</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">H</XMTok><XMTok role="UNKNOWN" font="italic">S</XMTok></XMApp><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">H</XMTok><XMTok role="UNKNOWN" font="italic">S</XMTok></XMApp></XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok meaning="0" role="NUMBER">0</XMTok></XMApp></XMath></Math>.</p>
            </para>
          </item>
          <item xml:id="I1.i2" fragid="I1.i2">
            <tag>•</tag>
            <para xml:id="I1.i2.p1" fragid="I1.i2.p1">
              <p>Since <Math mode="inline" xml:id="I1.i2.p1.m1" tex="AA^{\dagger}=A^{\dagger}A" text="A * A ^ dagger = A ^ dagger * A" fragid="I1.i2.p1.m1"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp></XMApp><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp><XMTok role="UNKNOWN" font="italic">A</XMTok></XMApp></XMApp></XMath></Math>, <Math mode="inline" xml:id="I1.i2.p1.m2" tex="H" text="H" fragid="I1.i2.p1.m2"><XMath><XMTok role="UNKNOWN" font="italic">H</XMTok></XMath></Math> and <Math mode="inline" xml:id="I1.i2.p1.m3" tex="S" text="S" fragid="I1.i2.p1.m3"><XMath><XMTok role="UNKNOWN" font="italic">S</XMTok></XMath></Math> have the same eigenvectors.</p>
            </para>
          </item>
          <item xml:id="I1.i3" fragid="I1.i3">
            <tag>•</tag>
            <para xml:id="I1.i3.p1" fragid="I1.i3.p1">
              <p>The imaginary part of the eigenvalues of <Math mode="inline" xml:id="I1.i3.p1.m1" tex="A" text="A" fragid="I1.i3.p1.m1"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> are equal to the eigenvalues of <Math mode="inline" xml:id="I1.i3.p1.m2" tex="S" text="S" fragid="I1.i3.p1.m2"><XMath><XMTok role="UNKNOWN" font="italic">S</XMTok></XMath></Math>, and the real parts are equal to the eigenvalues of <Math mode="inline" xml:id="I1.i3.p1.m3" tex="H" text="H" fragid="I1.i3.p1.m3"><XMath><XMTok role="UNKNOWN" font="italic">H</XMTok></XMath></Math>.</p>
            </para>
          </item>
        </itemize>
        <p>Because of the last property, one can simulate normal matrices and their corresponding non-Hermitian operators on quantum computers by using two separate registers to obtain the imaginary and the real parts of the eigenvalue individually. In that case, one uses two unitary operators <Math mode="inline" xml:id="S3.SS4.p1.m14" tex="U_{1}=e^{iH}" text="U _ 1 = e ^ (i * H)" fragid="S3.SS4.p1.m14"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">U</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok><XMTok role="UNKNOWN" font="italic">H</XMTok></XMApp></XMApp></XMApp></XMath></Math> and <Math mode="inline" xml:id="S3.SS4.p1.m15" tex="U_{2}=e^{S}" text="U _ 2 = e ^ S" fragid="S3.SS4.p1.m15"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">U</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">e</XMTok><XMTok role="UNKNOWN" font="italic">S</XMTok></XMApp></XMApp></XMath></Math> for the simulation. (Note that <Math mode="inline" xml:id="S3.SS4.p1.m16" tex="U_{2}" text="U _ 2" fragid="S3.SS4.p1.m16"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">U</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> is a unitary matrix because the exponential of a skew symmetric matrix is a unitary matrix.).
However, if a stochastic matrix is normal, it turns out that it is also doubly stochastic: i.e., its left and right principal eigenvectors are known to be a vector of all ones with the eigenvalue one. Therefore, instead of an approximate normal matrix, we shall use the closest Hermitian matrix <Math mode="inline" xml:id="S3.SS4.p1.m17" tex="H=\frac{1}{2}(A+A^{\dagger})" text="H = (1 / 2) * (A + A ^ dagger)" fragid="S3.SS4.p1.m17"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">H</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok mathstyle="text" meaning="divide" role="MULOP"/><XMTok meaning="1" role="NUMBER">1</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMDual><XMRef idref="S3.SS4.p1.m17.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMApp xml:id="S3.SS4.p1.m17.1" fragid="S3.SS4.p1.m17.1"><XMTok meaning="plus" role="ADDOP">+</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp></XMApp><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMApp></XMath></Math> in our simulations.</p>
      </para>
    </subsection>
    <subsection refnum="3.5" xml:id="S3.SS5" fragid="S3.SS5">
      <title><tag close=" ">3.5</tag>Incorporation of Other Information</title>
      <para xml:id="S3.SS5.p1" fragid="S3.SS5.p1">
        <p>As done in IsoRank <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx8" idref="bib.bibx8">Singh <emph>et al.</emph>(2007)Singh,
Xu, and Berger</ref>]</cite>, one can include further information, e.g. BLAST scores, into the quantum model as well in the following form:
<!-- %**** ppi-main.tex Line 200 **** --></p>
        <equation frefnum="(7)" refnum="7" xml:id="S3.E7" fragid="S3.E7">
          <Math mode="display" xml:id="S3.E7.m1" tex="\tilde{A}=H+B," text="tilde@(A) = H + B" fragid="S3.E7.m1">
            <XMath>
              <XMApp punctuation=",">
                <XMTok meaning="equals" role="RELOP">=</XMTok>
                <XMApp>
                  <XMTok name="tilde" role="OVERACCENT" stretchy="false">~</XMTok>
                  <XMTok role="UNKNOWN" font="italic">A</XMTok>
                </XMApp>
                <XMApp>
                  <XMTok meaning="plus" role="ADDOP">+</XMTok>
                  <XMTok role="UNKNOWN" font="italic">H</XMTok>
                  <XMTok role="UNKNOWN" font="italic">B</XMTok>
                </XMApp>
              </XMApp>
            </XMath>
          </Math>
        </equation>
        <p>where <Math mode="inline" xml:id="S3.SS5.p1.m1" tex="B" text="B" fragid="S3.SS5.p1.m1"><XMath><XMTok role="UNKNOWN" font="italic">B</XMTok></XMath></Math> and <Math mode="inline" xml:id="S3.SS5.p1.m2" tex="H" text="H" fragid="S3.SS5.p1.m2"><XMath><XMTok role="UNKNOWN" font="italic">H</XMTok></XMath></Math> are to be assumed to commute: <Math mode="inline" xml:id="S3.SS5.p1.m3" tex="BH-HB=0" text="B * H - H * B = 0" fragid="S3.SS5.p1.m3"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMApp><XMTok meaning="minus" role="ADDOP">-</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">B</XMTok><XMTok role="UNKNOWN" font="italic">H</XMTok></XMApp><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">H</XMTok><XMTok role="UNKNOWN" font="italic">B</XMTok></XMApp></XMApp><XMTok meaning="0" role="NUMBER">0</XMTok></XMApp></XMath></Math>.
Therefore, the time evolution can be written as:</p>
        <equation frefnum="(8)" refnum="8" xml:id="S3.E8" fragid="S3.E8">
          <Math mode="display" xml:id="S3.E8.m1" tex="e^{i\tilde{A}}=e^{iH+B}=e^{iH}e^{iB}" text="e ^ (i * tilde@(A)) = e ^ (i * H + B) = e ^ (i * H) * e ^ (i * B)" fragid="S3.E8.m1">
            <XMath>
              <XMApp>
                <XMTok meaning="multirelation"/>
                <XMApp>
                  <XMTok role="SUPERSCRIPTOP" scriptpos="post2"/>
                  <XMTok role="UNKNOWN" font="italic">e</XMTok>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMTok role="UNKNOWN" font="italic">i</XMTok>
                    <XMApp>
                      <XMTok name="tilde" role="OVERACCENT" stretchy="false">~</XMTok>
                      <XMTok role="UNKNOWN" font="italic">A</XMTok>
                    </XMApp>
                  </XMApp>
                </XMApp>
                <XMTok meaning="equals" role="RELOP">=</XMTok>
                <XMApp>
                  <XMTok role="SUPERSCRIPTOP" scriptpos="post2"/>
                  <XMTok role="UNKNOWN" font="italic">e</XMTok>
                  <XMApp>
                    <XMTok meaning="plus" role="ADDOP">+</XMTok>
                    <XMApp>
                      <XMTok meaning="times" role="MULOP">⁢</XMTok>
                      <XMTok role="UNKNOWN" font="italic">i</XMTok>
                      <XMTok role="UNKNOWN" font="italic">H</XMTok>
                    </XMApp>
                    <XMTok role="UNKNOWN" font="italic">B</XMTok>
                  </XMApp>
                </XMApp>
                <XMTok meaning="equals" role="RELOP">=</XMTok>
                <XMApp>
                  <XMTok meaning="times" role="MULOP">⁢</XMTok>
                  <XMApp>
                    <XMTok role="SUPERSCRIPTOP" scriptpos="post2"/>
                    <XMTok role="UNKNOWN" font="italic">e</XMTok>
                    <XMApp>
                      <XMTok meaning="times" role="MULOP">⁢</XMTok>
                      <XMTok role="UNKNOWN" font="italic">i</XMTok>
                      <XMTok role="UNKNOWN" font="italic">H</XMTok>
                    </XMApp>
                  </XMApp>
                  <XMApp>
                    <XMTok role="SUPERSCRIPTOP" scriptpos="post2"/>
                    <XMTok role="UNKNOWN" font="italic">e</XMTok>
                    <XMApp>
                      <XMTok meaning="times" role="MULOP">⁢</XMTok>
                      <XMTok role="UNKNOWN" font="italic">i</XMTok>
                      <XMTok role="UNKNOWN" font="italic">B</XMTok>
                    </XMApp>
                  </XMApp>
                </XMApp>
              </XMApp>
            </XMath>
          </Math>
        </equation>
        <p>Note that the above equation does not change the sparsity of the matrix <Math mode="inline" xml:id="S3.SS5.p1.m4" tex="A" text="A" fragid="S3.SS5.p1.m4"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math>; hence, it is still sparse and the evolution operator and the corresponding quantum circuit require polynomial time for the implementation <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx18" idref="bib.bibx18">Berry <emph>et al.</emph>(2007)Berry,
Ahokas, Cleve, and Sanders</ref>]</cite> (see Sec.<ref labelref="LABEL:Sec:Complexity" href="#S6" title="6 The Overall Complexity ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">6</text></ref> for the complexity analysis).</p>
      </para>
    </subsection>
  </section>
  <section refnum="4" xml:id="S4" fragid="S4">
    <title><tag close=" ">4</tag>Extracting Node Mappings From a Quantum State</title>
    <subsection refnum="4.1" xml:id="S4.SS1" fragid="S4.SS1">
      <title><tag close=" ">4.1</tag>Matching for a Pair of Networks</title>
      <para xml:id="S4.SS1.p1" fragid="S4.SS1.p1">
        <p>Generating a discrete solution from the final quantum state is known to be just solving a maximum weight matching problem. However, since fully obtaining a quantum state requires exponential time complexity <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx13" idref="bib.bibx13">Nielsen and Chuang(2010)</ref>]</cite>, we cannot apply classical matching algorithms directly.
Hence, engineering the order of the quantum registers in the measurement, we describe the following greedy strategy for the alignment:
Consider the eigenvector consists of two registers as
<Math mode="inline" xml:id="S4.SS1.p1.m1" tex="\left|\bm{x}\right\rangle" text="ket@(x)" fragid="S4.SS1.p1.m1"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS1.p1.m1.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok role="UNKNOWN" xml:id="S4.SS1.p1.m1.1" font="bold italic" fragid="S4.SS1.p1.m1.1">x</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math><Math mode="inline" xml:id="S4.SS1.p1.m2" tex="\left|\bm{y}\right\rangle" text="ket@(y)" fragid="S4.SS1.p1.m2"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS1.p1.m2.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMTok role="UNKNOWN" xml:id="S4.SS1.p1.m2.1" font="bold italic" fragid="S4.SS1.p1.m2.1">y</XMTok><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, where each register represents a network:</p>
        <enumerate xml:id="I2" fragid="I2">
          <item frefnum="1." refnum="1" xml:id="I2.i1" fragid="I2.i1">
            <tag>1.</tag>
            <para xml:id="I2.i1.p1" fragid="I2.i1.p1">
              <p>Apply a conditional measurement: when the first register is <Math mode="inline" xml:id="I2.i1.p1.m1" tex="x_{i}" text="x _ i" fragid="I2.i1.p1.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">x</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math>, measure the second register. For each measured <Math mode="inline" xml:id="I2.i1.p1.m2" tex="x_{i}" text="x _ i" fragid="I2.i1.p1.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">x</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math>, this generates a <Math mode="inline" xml:id="I2.i1.p1.m3" tex="y_{j}" text="y _ j" fragid="I2.i1.p1.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">y</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math>; therefore, <Math mode="inline" xml:id="I2.i1.p1.m4" tex="x_{i}" text="x _ i" fragid="I2.i1.p1.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">x</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math>s are matched to <Math mode="inline" xml:id="I2.i1.p1.m5" tex="y_{j}" text="y _ j" fragid="I2.i1.p1.m5"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">y</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math>s. Note that the measurement outcome is determined by the conditional probability: the probability of measuring <Math mode="inline" xml:id="I2.i1.p1.m6" tex="y_{j}" text="y _ j" fragid="I2.i1.p1.m6"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">y</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math> in the second register while the first register is <Math mode="inline" xml:id="I2.i1.p1.m7" tex="x_{i}" text="x _ i" fragid="I2.i1.p1.m7"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">x</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math>.</p>
            </para>
          </item>
          <item frefnum="2." refnum="2" xml:id="I2.i2" fragid="I2.i2">
            <tag>2.</tag>
            <para xml:id="I2.i2.p1" fragid="I2.i2.p1">
              <p>If there are duplicities and still unmatched nodes;
then apply a second type of conditional measurement: if the second register <Math mode="inline" xml:id="I2.i2.p1.m1" tex="y_{j}" text="y _ j" fragid="I2.i2.p1.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">y</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math>, measure the first register. This time for each <Math mode="inline" xml:id="I2.i2.p1.m2" tex="y_{j}" text="y _ j" fragid="I2.i2.p1.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">y</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math> an <Math mode="inline" xml:id="I2.i2.p1.m3" tex="x_{i}" text="x _ i" fragid="I2.i2.p1.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">x</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math> is obtained.</p>
            </para>
            <para xml:id="I2.i2.p2" fragid="I2.i2.p2">
              <p>This step is only useful when additional information is incorporated (<Math mode="inline" xml:id="I2.i2.p2.m1" tex="A+B" text="A + B" fragid="I2.i2.p2.m1"><XMath><XMApp><XMTok meaning="plus" role="ADDOP">+</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok role="UNKNOWN" font="italic">B</XMTok></XMApp></XMath></Math> is used) because the system is otherwise separable as <Math mode="inline" xml:id="I2.i2.p2.m2" tex="A=A_{1}\otimes A_{2}" text="A = A _ 1 tensor-product A _ 2" fragid="I2.i2.p2.m2"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok meaning="tensor-product" name="otimes" role="MULOP">⊗</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp></XMath></Math> and the conditional measurement outcome will be the same as the outcome obtained in the first step.</p>
            </para>
          </item>
          <item frefnum="3." refnum="3" xml:id="I2.i3" fragid="I2.i3">
            <tag>3.</tag>
            <para xml:id="I2.i3.p1" fragid="I2.i3.p1">
              <p>We combine these two different measurement outcomes obtained in the first and the second steps and begin matching from nodes whose scores are the highest.</p>
            </para>
          </item>
          <item frefnum="4." refnum="4" xml:id="I2.i4" fragid="I2.i4">
            <tag>4.</tag>
            <para xml:id="I2.i4.p1" fragid="I2.i4.p1">
              <p>If there are still unmatched nodes, statistical information about the other possibilities obtained during the measurement is used to match the remaining nodes.
<!-- %**** ppi-main.tex Line 225 **** --></p>
            </para>
          </item>
        </enumerate>
      </para>
      <para xml:id="S4.SS1.p2" fragid="S4.SS1.p2">
        <p>Since the main intuition of the algorithm gives a higher similarity score to the nodes whose neighbours have high scores; in the matching, the neighbours of the first matched nodes are given priority so as to generate a solution which is also connected.
In the end, we choose the largest connected component as the best solution to the alignment.</p>
      </para>
    </subsection>
    <subsection refnum="4.2" xml:id="S4.SS2" labels="LABEL:sec:MatchingMN" fragid="S4.SS2">
      <title><tag close=" ">4.2</tag>Matching for Multiple Networks</title>
      <para xml:id="S4.SS2.p1" fragid="S4.SS2.p1">
        <p>In the case of multiple networks, as done in ref.<cite class="ltx_citemacro_cite">[<ref href="#bib.bibx9" idref="bib.bibx9">Liao <emph>et al.</emph>(2009)Liao,
Lu, Baym, 0001, and Berger</ref>]</cite> an obvious approach is to align each possible pair of networks and derive a common solution for the multiple networks from these pairwise alignments.
However, the complexity of this approach grows exponentially with the number of networks.
Here, we shall follow a different approach which can be generalized easily to any number of networks:
Assume we have three networks <Math mode="inline" xml:id="S4.SS2.p1.m1" tex="G_{1}" text="G _ 1" fragid="S4.SS2.p1.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math>, <Math mode="inline" xml:id="S4.SS2.p1.m2" tex="G_{2}" text="G _ 2" fragid="S4.SS2.p1.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>, and <Math mode="inline" xml:id="S4.SS2.p1.m3" tex="G_{3}" text="G _ 3" fragid="S4.SS2.p1.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math> with nodes <Math mode="inline" xml:id="S4.SS2.p1.m4" tex="\{a_{1}\dots a_{m_{1}}\}" text="set@(a _ 1 * dots * a _ m _ 1)" fragid="S4.SS2.p1.m4"><XMath><XMDual><XMApp><XMTok meaning="set"/><XMRef idref="S4.SS2.p1.m4.1"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">{</XMTok><XMApp xml:id="S4.SS2.p1.m4.1" fragid="S4.SS2.p1.m4.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok name="dots" role="ID">…</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">m</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok role="CLOSE" stretchy="false">}</XMTok></XMWrap></XMDual></XMath></Math>, <Math mode="inline" xml:id="S4.SS2.p1.m5" tex="\{b_{1}\dots b_{m_{2}}\}" text="set@(b _ 1 * dots * b _ m _ 2)" fragid="S4.SS2.p1.m5"><XMath><XMDual><XMApp><XMTok meaning="set"/><XMRef idref="S4.SS2.p1.m5.1"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">{</XMTok><XMApp xml:id="S4.SS2.p1.m5.1" fragid="S4.SS2.p1.m5.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok name="dots" role="ID">…</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">m</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok role="CLOSE" stretchy="false">}</XMTok></XMWrap></XMDual></XMath></Math> and <Math mode="inline" xml:id="S4.SS2.p1.m6" tex="\{c_{1}\dots c_{m_{3}}\}" text="set@(c _ 1 * dots * c _ m _ 3)" fragid="S4.SS2.p1.m6"><XMath><XMDual><XMApp><XMTok meaning="set"/><XMRef idref="S4.SS2.p1.m6.1"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">{</XMTok><XMApp xml:id="S4.SS2.p1.m6.1" fragid="S4.SS2.p1.m6.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMTok name="dots" role="ID">…</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">m</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok role="CLOSE" stretchy="false">}</XMTok></XMWrap></XMDual></XMath></Math>, respectively.
Let also <Math mode="inline" xml:id="S4.SS2.p1.m7" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="S4.SS2.p1.m7"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS2.p1.m7.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S4.SS2.p1.m7.1" fragid="S4.SS2.p1.m7.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, <Math mode="inline" xml:id="S4.SS2.p1.m8" tex="\left|reg_{G_{2}}\right\rangle" text="ket@(r * e * g _ G _ 2)" fragid="S4.SS2.p1.m8"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS2.p1.m8.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S4.SS2.p1.m8.1" fragid="S4.SS2.p1.m8.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>, and <Math mode="inline" xml:id="S4.SS2.p1.m9" tex="\left|reg_{G_{3}}\right\rangle" text="ket@(r * e * g _ G _ 3)" fragid="S4.SS2.p1.m9"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS2.p1.m9.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S4.SS2.p1.m9.1" fragid="S4.SS2.p1.m9.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> represent the networks <Math mode="inline" xml:id="S4.SS2.p1.m10" tex="G_{1}" text="G _ 1" fragid="S4.SS2.p1.m10"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math>, <Math mode="inline" xml:id="S4.SS2.p1.m11" tex="G_{2}" text="G _ 2" fragid="S4.SS2.p1.m11"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>, and <Math mode="inline" xml:id="S4.SS2.p1.m12" tex="G_{3}" text="G _ 3" fragid="S4.SS2.p1.m12"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math>, respectively:</p>
        <itemize xml:id="I3" fragid="I3">
          <item xml:id="I3.i1" fragid="I3.i1">
            <tag>•</tag>
            <para xml:id="I3.i1.p1" fragid="I3.i1.p1">
              <p>Measuring <Math mode="inline" xml:id="I3.i1.p1.m1" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="I3.i1.p1.m1"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m1.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m1.1" fragid="I3.i1.p1.m1.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> alone and <Math mode="inline" xml:id="I3.i1.p1.m2" tex="\left|reg_{G_{2}}\right\rangle" text="ket@(r * e * g _ G _ 2)" fragid="I3.i1.p1.m2"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m2.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m2.1" fragid="I3.i1.p1.m2.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> and <Math mode="inline" xml:id="I3.i1.p1.m3" tex="\left|reg_{G_{3}}\right\rangle" text="ket@(r * e * g _ G _ 3)" fragid="I3.i1.p1.m3"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m3.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m3.1" fragid="I3.i1.p1.m3.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> together, we draw the conditional probabilities to see one of the nodes, <Math mode="inline" xml:id="I3.i1.p1.m4" tex="a_{i}" text="a _ i" fragid="I3.i1.p1.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math>, in <Math mode="inline" xml:id="I3.i1.p1.m5" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="I3.i1.p1.m5"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m5.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m5.1" fragid="I3.i1.p1.m5.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> and <Math mode="inline" xml:id="I3.i1.p1.m6" tex="b_{j}c_{k}" text="b _ j * c _ k" fragid="I3.i1.p1.m6"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMath></Math> in <Math mode="inline" xml:id="I3.i1.p1.m7" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="I3.i1.p1.m7"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m7.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m7.1" fragid="I3.i1.p1.m7.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math><Math mode="inline" xml:id="I3.i1.p1.m8" tex="\left|reg_{G_{3}}\right\rangle" text="ket@(r * e * g _ G _ 3)" fragid="I3.i1.p1.m8"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m8.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m8.1" fragid="I3.i1.p1.m8.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>.
In other words, when <Math mode="inline" xml:id="I3.i1.p1.m9" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="I3.i1.p1.m9"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m9.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m9.1" fragid="I3.i1.p1.m9.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> is <Math mode="inline" xml:id="I3.i1.p1.m10" tex="a_{i}" text="a _ i" fragid="I3.i1.p1.m10"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math>, the probability to see <Math mode="inline" xml:id="I3.i1.p1.m11" tex="b_{j}c_{k}" text="b _ j * c _ k" fragid="I3.i1.p1.m11"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMath></Math> in <Math mode="inline" xml:id="I3.i1.p1.m12" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="I3.i1.p1.m12"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m12.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m12.1" fragid="I3.i1.p1.m12.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math><Math mode="inline" xml:id="I3.i1.p1.m13" tex="\left|reg_{G_{3}}\right\rangle" text="ket@(r * e * g _ G _ 3)" fragid="I3.i1.p1.m13"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i1.p1.m13.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i1.p1.m13.1" fragid="I3.i1.p1.m13.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> is obtained.
This results in a matching of <Math mode="inline" xml:id="I3.i1.p1.m14" tex="a_{i}-b_{j}c_{k}" text="a _ i - b _ j * c _ k" fragid="I3.i1.p1.m14"><XMath><XMApp><XMTok meaning="minus" role="ADDOP">-</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMApp></XMath></Math>.
Note that in the real implementation on a quantum computer, one just assigns the nodes as a result of the measurement outcome.</p>
              <itemize xml:id="I3.I1" fragid="I3.I1">
                <item xml:id="I3.I1.i1" fragid="I3.I1.i1">
                  <tag>
                    <text font="bold">–</text>
                  </tag>
                  <para xml:id="I3.I1.i1.p1" fragid="I3.I1.i1.p1">
                    <p>We match nodes initiating from the largest probability, or the most commonly seen measurement outcome.</p>
                  </para>
                </item>
                <item xml:id="I3.I1.i2" fragid="I3.I1.i2">
                  <tag>
                    <text font="bold">–</text>
                  </tag>
                  <para xml:id="I3.I1.i2.p1" fragid="I3.I1.i2.p1">
                    <p>As done in the case of two networks, the priority given to the neighbours of the first matched nodes.</p>
                  </para>
                </item>
              </itemize>
            </para>
          </item>
          <item xml:id="I3.i2" fragid="I3.i2">
            <tag>•</tag>
            <para xml:id="I3.i2.p1" fragid="I3.i2.p1">
              <p>If the measurement is no longer provide valuable information to match further nodes, then we measure <Math mode="inline" xml:id="I3.i2.p1.m1" tex="\left|reg_{G_{2}}\right\rangle" text="ket@(r * e * g _ G _ 2)" fragid="I3.i2.p1.m1"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i2.p1.m1.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i2.p1.m1.1" fragid="I3.i2.p1.m1.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> alone and <Math mode="inline" xml:id="I3.i2.p1.m2" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="I3.i2.p1.m2"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i2.p1.m2.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i2.p1.m2.1" fragid="I3.i2.p1.m2.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> and <Math mode="inline" xml:id="I3.i2.p1.m3" tex="\left|reg_{G_{3}}\right\rangle" text="ket@(r * e * g _ G _ 3)" fragid="I3.i2.p1.m3"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i2.p1.m3.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i2.p1.m3.1" fragid="I3.i2.p1.m3.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> together. This gives the probabilities to see one of the nodes, <Math mode="inline" xml:id="I3.i2.p1.m4" tex="b_{j}" text="b _ j" fragid="I3.i2.p1.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math>, in <Math mode="inline" xml:id="I3.i2.p1.m5" tex="\left|reg_{G_{2}}\right\rangle" text="ket@(r * e * g _ G _ 2)" fragid="I3.i2.p1.m5"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i2.p1.m5.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i2.p1.m5.1" fragid="I3.i2.p1.m5.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> and <Math mode="inline" xml:id="I3.i2.p1.m6" tex="a_{i}c_{k}" text="a _ i * c _ k" fragid="I3.i2.p1.m6"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMath></Math> in <Math mode="inline" xml:id="I3.i2.p1.m7" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="I3.i2.p1.m7"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i2.p1.m7.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i2.p1.m7.1" fragid="I3.i2.p1.m7.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math><Math mode="inline" xml:id="I3.i2.p1.m8" tex="\left|reg_{G_{3}}\right\rangle" text="ket@(r * e * g _ G _ 3)" fragid="I3.i2.p1.m8"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="I3.i2.p1.m8.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="I3.i2.p1.m8.1" fragid="I3.i2.p1.m8.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math>. Then we combine this measurement result with the previous measurement result to match the unmatched nodes.</p>
            </para>
          </item>
        </itemize>
      </para>
      <para xml:id="S4.SS2.p2" fragid="S4.SS2.p2">
        <p>One can also go further and draw probabilities for <Math mode="inline" xml:id="S4.SS2.p2.m1" tex="c_{k}-a_{i}b_{j}" text="c _ k - a _ i * b _ j" fragid="S4.SS2.p2.m1"><XMath><XMApp><XMTok meaning="minus" role="ADDOP">-</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMApp></XMApp></XMath></Math> and combine them with the previous results.
<!-- %**** ppi-main.tex Line 250 **** -->However, while different measurement settings increase the statistical confidence in the measurement results, it increases the complexity of the algorithm. As noted before, if <Math mode="inline" xml:id="S4.SS2.p2.m2" tex="\left|reg_{2}\right\rangle" text="ket@(r * e * g _ 2)" fragid="S4.SS2.p2.m2"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS2.p2.m2.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S4.SS2.p2.m2.1" fragid="S4.SS2.p2.m2.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> is separable at the beginning: i.e., <Math mode="inline" xml:id="S4.SS2.p2.m3" tex="\left|reg_{2}\right\rangle=\left|reg_{G_{1}}\right\rangle\otimes\left|reg_{G_{%&#10;2}}\right\rangle\otimes\dots\otimes\left|reg_{G_{m}}\right\rangle" text="ket@(r * e * g _ 2) = ket@(r * e * g _ G _ 1) tensor-product ket@(r * e * g _ G _ 2) tensor-product dots tensor-product ket@(r * e * g _ G _ m)" fragid="S4.SS2.p2.m3"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS2.p2.m3.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S4.SS2.p2.m3.1" fragid="S4.SS2.p2.m3.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMApp><XMTok meaning="tensor-product" name="otimes" role="MULOP">⊗</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS2.p2.m3.2"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S4.SS2.p2.m3.2" fragid="S4.SS2.p2.m3.2"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS2.p2.m3.3"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S4.SS2.p2.m3.3" fragid="S4.SS2.p2.m3.3"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMTok name="dots" role="ID">…</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S4.SS2.p2.m3.4"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S4.SS2.p2.m3.4" fragid="S4.SS2.p2.m3.4"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMApp></XMApp></XMath></Math>, then the other measurements also produce the same result as the first measurement setting, <Math mode="inline" xml:id="S4.SS2.p2.m4" tex="G_{1i}-G_{2j}\dots G_{mk}" text="G _ (1 * i) - G _ (2 * j) * dots * G _ (m * k)" fragid="S4.SS2.p2.m4"><XMath><XMApp><XMTok meaning="minus" role="ADDOP">-</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMApp><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMApp><XMTok name="dots" role="ID">…</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMApp></XMApp></XMath></Math>.
Thus, only the first measurement setting is used to conclude the matching of the nodes.</p>
      </para>
      <figure frefnum="Figure 1" placement="ht" refnum="1" xml:id="S4.F1" fragid="S4.F1">
        <figure frefnum="(a)" refnum="a" xml:id="S4.F0.sf1" align="center" fragid="S4.F0.sf1">
          <graphics candidates="A1.eps" graphic="A1" options="scale=0.5" xml:id="S4.F0.sf1.g1" fragid="S4.F0.sf1.g1" imagesrc="x86.png" imagewidth="278" imageheight="94"/>
          <toccaption><tag close=" ">a</tag> <Math mode="inline" xml:id="S4.F0.sf1.m1" tex="G_{1}" text="G _ 1" fragid="S4.F0.sf1.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math></toccaption>
          <caption><tag close=" ">(a)</tag> <Math mode="inline" xml:id="S4.F0.sf1.m2" tex="G_{1}" text="G _ 1" fragid="S4.F0.sf1.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math></caption>
        </figure>
        <figure frefnum="(b)" refnum="b" xml:id="S4.F0.sf2" align="center" fragid="S4.F0.sf2">
          <graphics candidates="B.eps" graphic="B" options="scale=0.5" xml:id="S4.F0.sf2.g1" fragid="S4.F0.sf2.g1" imagesrc="x87.png" imagewidth="128" imageheight="94"/>
          <toccaption><tag close=" ">b</tag> <Math mode="inline" xml:id="S4.F0.sf2.m1" tex="G_{2}" text="G _ 2" fragid="S4.F0.sf2.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math></toccaption>
          <caption><tag close=" ">(b)</tag> <Math mode="inline" xml:id="S4.F0.sf2.m2" tex="G_{2}" text="G _ 2" fragid="S4.F0.sf2.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math></caption>
        </figure>
        <figure frefnum="(c)" refnum="c" xml:id="S4.F0.sf3" labels="LABEL:fig:networks" align="center" fragid="S4.F0.sf3">
          <graphics candidates="C1.eps" graphic="C1" options="scale=0.5" xml:id="S4.F0.sf3.g1" fragid="S4.F0.sf3.g1" imagesrc="x88.png" imagewidth="128" imageheight="94"/>
          <toccaption><tag close=" ">c</tag> <Math mode="inline" xml:id="S4.F0.sf3.m1" tex="G_{3}" text="G _ 3" fragid="S4.F0.sf3.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math></toccaption>
          <caption><tag close=" ">(c)</tag> <Math mode="inline" xml:id="S4.F0.sf3.m2" tex="G_{3}" text="G _ 3" fragid="S4.F0.sf3.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math></caption>
        </figure>
        <toccaption class="ltx_centering"><tag close=" ">1</tag> Example Networks </toccaption>
        <caption class="ltx_centering"><tag close=": ">Figure 1</tag> Example Networks </caption>
      </figure>
    </subsection>
  </section>
  <section refnum="5" xml:id="S5" fragid="S5">
    <title><tag close=" ">5</tag>Numerical Examples</title>
    <para xml:id="S5.p1" fragid="S5.p1">
      <p>Because of the computational difficulty in simulating quantum computers on classical computers (The complexity grows exponentially with the number of qubits involved in the simulation. PEA requires also sufficient number of qubits on the first register to hold eigenvalue.), here we only aim to show the capability of the algorithm when a fully functional quantum computer is available.
Therefore, we shall use merely trivial examples given
in Fig.<ref labelref="LABEL:fig:networks" href="#S4.F0.sf3" title="(c) ‣ Figure 1 ‣ 4.2 Matching for Multiple Networks ‣ 4 Extracting Node Mappings From a Quantum State ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">c</text></ref> for which one can see optimal solutions easily.
For the large non-trivial networks, since both IsoRank and the quantum approach are based on the principal eigenvector; we expect the success of the algorithm to be similar to IsoRank even though the matching algorithm defined here is different than the one in IsoRank.</p>
    </para>
    <subsection refnum="5.1" xml:id="S5.SS1" fragid="S5.SS1">
      <title><tag close=" ">5.1</tag>Example-1: Alignment of Network Pairs</title>
      <para xml:id="S5.SS1.p1" fragid="S5.SS1.p1">
        <p>In the case of the alignment of two networks <Math mode="inline" xml:id="S5.SS1.p1.m1" tex="G_{1}" text="G _ 1" fragid="S5.SS1.p1.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math>-<Math mode="inline" xml:id="S5.SS1.p1.m2" tex="G_{2}" text="G _ 2" fragid="S5.SS1.p1.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>, the possible probability outcomes are shown in Fig.<ref labelref="LABEL:fig:graphsA" href="#S5.F1.sf1" title="(a) ‣ Figure 2 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">a</text></ref>; where it is first assumed that <Math mode="inline" xml:id="S5.SS1.p1.m3" tex="\left|reg_{G_{1}}\right\rangle=a_{i}" text="ket@(r * e * g _ G _ 1) = a _ i" fragid="S5.SS1.p1.m3"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.SS1.p1.m3.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.SS1.p1.m3.1" fragid="S5.SS1.p1.m3.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMApp></XMath></Math>, then probabilities in the collapsed state are found for for each <Math mode="inline" xml:id="S5.SS1.p1.m4" tex="bj" text="b * j" fragid="S5.SS1.p1.m4"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp></XMath></Math>.
Note that since the collapsed state is not normalized, it represents conditional probabilities: e.g., the probability of <Math mode="inline" xml:id="S5.SS1.p1.m5" tex="\left|reg_{G_{2}}\right\rangle=b_{2}" text="ket@(r * e * g _ G _ 2) = b _ 2" fragid="S5.SS1.p1.m5"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.SS1.p1.m5.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.SS1.p1.m5.1" fragid="S5.SS1.p1.m5.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMath></Math> when <Math mode="inline" xml:id="S5.SS1.p1.m6" tex="\left|reg_{G_{1}}\right\rangle=a_{1}" text="ket@(r * e * g _ G _ 1) = a _ 1" fragid="S5.SS1.p1.m6"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.SS1.p1.m6.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.SS1.p1.m6.1" fragid="S5.SS1.p1.m6.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMath></Math>. The same approach is also applied to <Math mode="inline" xml:id="S5.SS1.p1.m7" tex="G_{2}" text="G _ 2" fragid="S5.SS1.p1.m7"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>-<Math mode="inline" xml:id="S5.SS1.p1.m8" tex="G_{3}" text="G _ 3" fragid="S5.SS1.p1.m8"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math> and the probabilities are shown in Fig.<ref labelref="LABEL:fig:graphsC" href="#S5.F1.sf3" title="(c) ‣ Figure 2 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">c</text></ref>.
<!-- %**** ppi-main.tex Line 275 **** -->The matching algorithm applied to the outcomes in Fig.<ref labelref="LABEL:fig:graphsA" href="#S5.F1.sf1" title="(a) ‣ Figure 2 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">a</text></ref> and Fig.<ref labelref="LABEL:fig:graphsC" href="#S5.F1.sf3" title="(c) ‣ Figure 2 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">c</text></ref> procures the exact alignments for the both pairs of the networks.</p>
      </para>
      <para xml:id="S5.SS1.p2" fragid="S5.SS1.p2">
        <p>Fig.<ref labelref="LABEL:fig:graphsB" href="#S5.F1.sf2" title="(b) ‣ Figure 2 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">b</text></ref> and Fig.<ref labelref="LABEL:fig:graphsD" href="#S5.F1.sf4" title="(d) ‣ Figure 2 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">d</text></ref> also show the probability outcomes for the alignment of the same networks: <Math mode="inline" xml:id="S5.SS1.p2.m1" tex="G_{1}" text="G _ 1" fragid="S5.SS1.p2.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math>-<Math mode="inline" xml:id="S5.SS1.p2.m2" tex="G_{2}" text="G _ 2" fragid="S5.SS1.p2.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.SS1.p2.m3" tex="G_{2}" text="G _ 2" fragid="S5.SS1.p2.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>-<Math mode="inline" xml:id="S5.SS1.p2.m4" tex="G_{3}" text="G _ 3" fragid="S5.SS1.p2.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math>; however, in these figures, instead of <Math mode="inline" xml:id="S5.SS1.p2.m5" tex="A" text="A" fragid="S5.SS1.p2.m5"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math>, approximate Hermitian matrices found by <Math mode="inline" xml:id="S5.SS1.p2.m6" tex="A=1/2(A+A^{\dagger})" text="A = (1 / 2) * (A + A ^ dagger)" fragid="S5.SS1.p2.m6"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok mathstyle="inline" meaning="divide" role="MULOP">/</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMDual><XMRef idref="S5.SS1.p2.m6.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMApp xml:id="S5.SS1.p2.m6.1" fragid="S5.SS1.p2.m6.1"><XMTok meaning="plus" role="ADDOP">+</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp></XMApp><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMApp></XMath></Math> are used. While the probabilities slightly differ in comparison to Fig.<ref labelref="LABEL:fig:graphsA" href="#S5.F1.sf1" title="(a) ‣ Figure 2 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">a</text></ref> and Fig.<ref labelref="LABEL:fig:graphsC" href="#S5.F1.sf3" title="(c) ‣ Figure 2 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">c</text></ref>, they still conclude with the same alignments.</p>
      </para>
    </subsection>
    <subsection refnum="5.2" xml:id="S5.SS2" fragid="S5.SS2">
      <title><tag close=" ">5.2</tag>Example-2: Alignment of Multiple Networks</title>
      <para xml:id="S5.SS2.p1" fragid="S5.SS2.p1">
        <p>As an example for the multiple network alignment, we use <Math mode="inline" xml:id="S5.SS2.p1.m1" tex="G_{1}" text="G _ 1" fragid="S5.SS2.p1.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math>, <Math mode="inline" xml:id="S5.SS2.p1.m2" tex="G_{2}" text="G _ 2" fragid="S5.SS2.p1.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.SS2.p1.m3" tex="G_{3}" text="G _ 3" fragid="S5.SS2.p1.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math> shown in Fig.<ref labelref="LABEL:fig:networks" href="#S4.F0.sf3" title="(c) ‣ Figure 1 ‣ 4.2 Matching for Multiple Networks ‣ 4 Extracting Node Mappings From a Quantum State ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">c</text></ref> and follow a similar method to the alignment of two networks:
First, we assume <Math mode="inline" xml:id="S5.SS2.p1.m4" tex="\left|reg_{G_{1}}\right\rangle=a_{i}" text="ket@(r * e * g _ G _ 1) = a _ i" fragid="S5.SS2.p1.m4"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.SS2.p1.m4.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.SS2.p1.m4.1" fragid="S5.SS2.p1.m4.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMApp></XMath></Math>, then find the probability of seeing <Math mode="inline" xml:id="S5.SS2.p1.m5" tex="\left|reg_{G_{2}}reg_{G_{2}}\right\rangle=b_{j}c_{k}" text="ket@(r * e * g _ G _ 2 * r * e * g _ G _ 2) = b _ j * c _ k" fragid="S5.SS2.p1.m5"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.SS2.p1.m5.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.SS2.p1.m5.1" fragid="S5.SS2.p1.m5.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post3"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMApp></XMath></Math> in the unnormalized collapsed state which represents the conditional probabilities.
The probabilities are shown in Fig.<ref labelref="LABEL:fig:graphsMN1" href="#S5.F2.sf1" title="(a) ‣ Figure 3 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">a</text></ref>, where the exact matrix is used. Fig.<ref labelref="LABEL:fig:graphsMN1" href="#S5.F2.sf1" title="(a) ‣ Figure 3 ‣ 5.2 Example-2: Alignment of Multiple Networks ‣ 5 Numerical Examples ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">a</text></ref> represents the probabilities when the Hermitian matrix <Math mode="inline" xml:id="S5.SS2.p1.m6" tex="A=1/2(A+A^{\dagger})" text="A = (1 / 2) * (A + A ^ dagger)" fragid="S5.SS2.p1.m6"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok mathstyle="inline" meaning="divide" role="MULOP">/</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMDual><XMRef idref="S5.SS2.p1.m6.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMApp xml:id="S5.SS2.p1.m6.1" fragid="S5.SS2.p1.m6.1"><XMTok meaning="plus" role="ADDOP">+</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok name="dagger" role="MULOP">†</XMTok></XMApp></XMApp><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMApp></XMath></Math> is used.
Giving the priority to the neighbors of the first matched nodes as explained in Sec.<ref labelref="LABEL:sec:MatchingMN" href="#S4.SS2" title="4.2 Matching for Multiple Networks ‣ 4 Extracting Node Mappings From a Quantum State ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">4.2</text></ref>, the exact same matching can be obtained from both of the figures.</p>
      </para>
      <figure frefnum="Figure 2" placement="h" refnum="2" xml:id="S5.F2" fragid="S5.F2">
        <figure frefnum="(a)" refnum="a" xml:id="S5.F1.sf1" labels="LABEL:fig:graphsA" align="center" fragid="S5.F1.sf1">
          <graphics candidates="fig4x4.eps" graphic="fig4x4" options="width=216.81pt" xml:id="S5.F1.sf1.g1" fragid="S5.F1.sf1.g1" imagesrc="x89.png" imagewidth="338" imageheight="158"/>
          <toccaption><tag close=" ">a</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F1.sf1.m1" tex="G_{2}" text="G _ 2" fragid="S5.F1.sf1.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F1.sf1.m2" tex="G_{3}" text="G _ 3" fragid="S5.F1.sf1.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math></toccaption>
          <caption><tag close=" ">(a)</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F1.sf1.m3" tex="G_{2}" text="G _ 2" fragid="S5.F1.sf1.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F1.sf1.m4" tex="G_{3}" text="G _ 3" fragid="S5.F1.sf1.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math></caption>
        </figure>
        <figure frefnum="(b)" refnum="b" xml:id="S5.F1.sf2" labels="LABEL:fig:graphsB" align="center" fragid="S5.F1.sf2">
          <graphics candidates="fig4x4-1.eps" graphic="fig4x4-1" options="width=216.81pt" xml:id="S5.F1.sf2.g1" fragid="S5.F1.sf2.g1" imagesrc="x90.png" imagewidth="338" imageheight="158"/>
          <toccaption><tag close=" ">b</tag> Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F1.sf2.m1" tex="G_{2}" text="G _ 2" fragid="S5.F1.sf2.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F1.sf2.m2" tex="G_{3}" text="G _ 3" fragid="S5.F1.sf2.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math> when the approximate Hermitian matrix is used.</toccaption>
          <caption><tag close=" ">(b)</tag> Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F1.sf2.m3" tex="G_{2}" text="G _ 2" fragid="S5.F1.sf2.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F1.sf2.m4" tex="G_{3}" text="G _ 3" fragid="S5.F1.sf2.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math> when the approximate Hermitian matrix is used.</caption>
        </figure>
        <figure frefnum="(c)" refnum="c" xml:id="S5.F1.sf3" labels="LABEL:fig:graphsC" align="center" fragid="S5.F1.sf3">
          <graphics candidates="fig8x4.eps" graphic="fig8x4" options="width=216.81pt" xml:id="S5.F1.sf3.g1" fragid="S5.F1.sf3.g1" imagesrc="x91.png" imagewidth="338" imageheight="158"/>
          <toccaption><tag close=" ">c</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F1.sf3.m1" tex="G_{1}" text="G _ 1" fragid="S5.F1.sf3.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F1.sf3.m2" tex="G_{2}" text="G _ 2" fragid="S5.F1.sf3.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math></toccaption>
          <caption><tag close=" ">(c)</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F1.sf3.m3" tex="G_{1}" text="G _ 1" fragid="S5.F1.sf3.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F1.sf3.m4" tex="G_{2}" text="G _ 2" fragid="S5.F1.sf3.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math></caption>
        </figure>
        <figure frefnum="(d)" refnum="d" xml:id="S5.F1.sf4" labels="LABEL:fig:graphs1 LABEL:fig:graphsD" align="center" fragid="S5.F1.sf4">
          <graphics candidates="fig8x4-1.eps" graphic="fig8x4-1" options="width=216.81pt" xml:id="S5.F1.sf4.g1" fragid="S5.F1.sf4.g1" imagesrc="x92.png" imagewidth="338" imageheight="158"/>
          <toccaption><tag close=" ">d</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F1.sf4.m1" tex="G_{1}" text="G _ 1" fragid="S5.F1.sf4.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F1.sf4.m2" tex="G_{2}" text="G _ 2" fragid="S5.F1.sf4.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> when the approximate Hermitian matrix is used.</toccaption>
          <caption><tag close=" ">(d)</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F1.sf4.m3" tex="G_{1}" text="G _ 1" fragid="S5.F1.sf4.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F1.sf4.m4" tex="G_{2}" text="G _ 2" fragid="S5.F1.sf4.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> when the approximate Hermitian matrix is used.</caption>
        </figure>
        <!-- %**** ppi-main.tex Line 300 **** -->
        <toccaption class="ltx_centering"><tag close=" ">2</tag> Expected probability outcome for the alignment of pairs of the networks</toccaption>
        <caption class="ltx_centering"><tag close=": ">Figure 2</tag> Expected probability outcome for the alignment of pairs of the networks</caption>
      </figure>
      <figure frefnum="Figure 3" placement="h" refnum="3" xml:id="S5.F3" fragid="S5.F3">
        <figure frefnum="(a)" refnum="a" xml:id="S5.F2.sf1" labels="LABEL:fig:graphsMN1" align="center" fragid="S5.F2.sf1">
          <graphics candidates="fig8x4x4.eps" graphic="fig8x4x4" options="width=542.025pt" xml:id="S5.F2.sf1.g1" fragid="S5.F2.sf1.g1" imagesrc="x93.png" imagewidth="843" imageheight="394"/>
          <toccaption><tag close=" ">a</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F2.sf1.m1" tex="G_{1}" text="G _ 1" fragid="S5.F2.sf1.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F2.sf1.m2" tex="G_{2}" text="G _ 2" fragid="S5.F2.sf1.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math></toccaption>
          <caption><tag close=" ">(a)</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F2.sf1.m3" tex="G_{1}" text="G _ 1" fragid="S5.F2.sf1.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F2.sf1.m4" tex="G_{2}" text="G _ 2" fragid="S5.F2.sf1.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math></caption>
        </figure>
        <figure frefnum="(b)" refnum="b" xml:id="S5.F2.sf2" labels="LABEL:fig:graphs2 LABEL:fig:graphsMN2" align="center" fragid="S5.F2.sf2">
          <graphics candidates="fig8x4x4-1.eps" graphic="fig8x4x4-1" options="width=542.025pt" xml:id="S5.F2.sf2.g1" fragid="S5.F2.sf2.g1" imagesrc="x94.png" imagewidth="843" imageheight="394"/>
          <toccaption><tag close=" ">b</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F2.sf2.m1" tex="G_{1}" text="G _ 1" fragid="S5.F2.sf2.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F2.sf2.m2" tex="G_{2}" text="G _ 2" fragid="S5.F2.sf2.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> when the approximate Hermitian matrix is used.</toccaption>
          <caption><tag close=" ">(b)</tag>Probabilities for matching of the nodes of <Math mode="inline" xml:id="S5.F2.sf2.m3" tex="G_{1}" text="G _ 1" fragid="S5.F2.sf2.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math> and <Math mode="inline" xml:id="S5.F2.sf2.m4" tex="G_{2}" text="G _ 2" fragid="S5.F2.sf2.m4"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math> when the approximate Hermitian matrix is used.</caption>
        </figure>
        <toccaption class="ltx_centering"><tag close=" ">3</tag> Matching Matrix for the networks <Math mode="inline" xml:id="S5.F3.m1" tex="G_{1}" text="G _ 1" fragid="S5.F3.m1"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math>, <Math mode="inline" xml:id="S5.F3.m2" tex="G_{2}" text="G _ 2" fragid="S5.F3.m2"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>, and <Math mode="inline" xml:id="S5.F3.m3" tex="G_{3}" text="G _ 3" fragid="S5.F3.m3"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math>. While the x-axis represents the nodes, <Math mode="inline" xml:id="S5.F3.m4" tex="a_{i}b_{j}c_{k}" text="a _ i * b _ j * c _ k" fragid="S5.F3.m4"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMath></Math>; the y-axis is the unnormalized conditional probabilities: if <Math mode="inline" xml:id="S5.F3.m5" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="S5.F3.m5"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.F3.m5.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.F3.m5.1" fragid="S5.F3.m5.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post6"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> is in <Math mode="inline" xml:id="S5.F3.m6" tex="a_{i}" text="a _ i" fragid="S5.F3.m6"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math> state, then the probability to measure <Math mode="inline" xml:id="S5.F3.m7" tex="\left|reg_{G_{2}}\right\rangle\left|reg_{G_{3}}\right\rangle" text="ket@(r * e * g _ G _ 2) * ket@(r * e * g _ G _ 3)" fragid="S5.F3.m7"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.F3.m7.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.F3.m7.1" fragid="S5.F3.m7.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post6"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.F3.m7.2"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.F3.m7.2" fragid="S5.F3.m7.2"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post6"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMApp></XMath></Math> in <Math mode="inline" xml:id="S5.F3.m8" tex="b_{j}c_{k}" text="b _ j * c _ k" fragid="S5.F3.m8"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMath></Math> state in the collapsed quantum state is shown. </toccaption>
        <caption class="ltx_centering"><tag close=": ">Figure 3</tag> Matching Matrix for the networks <Math mode="inline" xml:id="S5.F3.m9" tex="G_{1}" text="G _ 1" fragid="S5.F3.m9"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMath></Math>, <Math mode="inline" xml:id="S5.F3.m10" tex="G_{2}" text="G _ 2" fragid="S5.F3.m10"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMath></Math>, and <Math mode="inline" xml:id="S5.F3.m11" tex="G_{3}" text="G _ 3" fragid="S5.F3.m11"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMath></Math>. While the x-axis represents the nodes, <Math mode="inline" xml:id="S5.F3.m12" tex="a_{i}b_{j}c_{k}" text="a _ i * b _ j * c _ k" fragid="S5.F3.m12"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMath></Math>; the y-axis is the unnormalized conditional probabilities: if <Math mode="inline" xml:id="S5.F3.m13" tex="\left|reg_{G_{1}}\right\rangle" text="ket@(r * e * g _ G _ 1)" fragid="S5.F3.m13"><XMath><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.F3.m13.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.F3.m13.1" fragid="S5.F3.m13.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post6"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMath></Math> is in <Math mode="inline" xml:id="S5.F3.m14" tex="a_{i}" text="a _ i" fragid="S5.F3.m14"><XMath><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">i</XMTok></XMApp></XMath></Math> state, then the probability to measure <Math mode="inline" xml:id="S5.F3.m15" tex="\left|reg_{G_{2}}\right\rangle\left|reg_{G_{3}}\right\rangle" text="ket@(r * e * g _ G _ 2) * ket@(r * e * g _ G _ 3)" fragid="S5.F3.m15"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.F3.m15.1"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.F3.m15.1" fragid="S5.F3.m15.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post6"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="S5.F3.m15.2"/></XMApp><XMWrap><XMTok role="OPEN">|</XMTok><XMApp xml:id="S5.F3.m15.2" fragid="S5.F3.m15.2"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">r</XMTok><XMTok role="UNKNOWN" font="italic">e</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post5"/><XMTok role="UNKNOWN" font="italic">g</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post6"/><XMTok role="UNKNOWN" font="italic">G</XMTok><XMTok meaning="3" role="NUMBER">3</XMTok></XMApp></XMApp></XMApp><XMTok name="rangle" role="CLOSE">⟩</XMTok></XMWrap></XMDual></XMApp></XMath></Math> in <Math mode="inline" xml:id="S5.F3.m16" tex="b_{j}c_{k}" text="b _ j * c _ k" fragid="S5.F3.m16"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">b</XMTok><XMTok role="UNKNOWN" font="italic">j</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post4"/><XMTok role="UNKNOWN" font="italic">c</XMTok><XMTok role="UNKNOWN" font="italic">k</XMTok></XMApp></XMApp></XMath></Math> state in the collapsed quantum state is shown. </caption>
      </figure>
    </subsection>
  </section>
  <section refnum="6" xml:id="S6" labels="LABEL:Sec:Complexity" fragid="S6">
    <title><tag close=" ">6</tag>The Overall Complexity</title>
    <para xml:id="S6.p1" fragid="S6.p1">
      <p>It is proven that the efficient (polynomial time) simulation of a sparse operator on quantum computers is possible when the number of entries is bounded polynomially by the number of qubits and the norm of the matrix is less than or equal to the degree of this polynomial <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx19" idref="bib.bibx19">Aharonov and Ta-Shma(2003)</ref>]</cite>.
There have been also algorithms presented to simulate such sparse operators in polynomial time <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx18" idref="bib.bibx18">Berry <emph>et al.</emph>(2007)Berry,
Ahokas, Cleve, and Sanders</ref>, <ref href="#bib.bibx20" idref="bib.bibx20">Childs and Kothari(2011)</ref>]</cite>.
As a result, since the adjacency matrices of the PPI networks sparse, they can be simulated efficiently on quantum computers.</p>
    </para>
    <para xml:id="S6.p2" fragid="S6.p2">
      <p>In the implementation of the operator <Math mode="inline" xml:id="S6.p2.m1" tex="A" text="A" fragid="S6.p2.m1"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math>, quantum circuits for each graph can be generated separately since it is the Kronecker product of the normalized adjacency matrices: <Math mode="inline" xml:id="S6.p2.m2" tex="A=A_{1}\otimes A_{2}\otimes\dots\otimes A_{m}" text="A = A _ 1 tensor-product A _ 2 tensor-product dots tensor-product A _ m" fragid="S6.p2.m2"><XMath><XMApp><XMTok meaning="equals" role="RELOP">=</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMApp><XMTok meaning="tensor-product" name="otimes" role="MULOP">⊗</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok meaning="1" role="NUMBER">1</XMTok></XMApp><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMTok name="dots" role="ID">…</XMTok><XMApp><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok></XMApp></XMApp></XMApp></XMath></Math>, where <Math mode="inline" xml:id="S6.p2.m3" tex="m" text="m" fragid="S6.p2.m3"><XMath><XMTok role="UNKNOWN" font="italic">m</XMTok></XMath></Math> represents the number of networks. Therefore the total complexity of implementing <Math mode="inline" xml:id="S6.p2.m4" tex="A" text="A" fragid="S6.p2.m4"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> can be defined as:
<!-- %**** ppi-main.tex Line 325 **** --></p>
      <equation frefnum="(9)" refnum="9" xml:id="S6.E9" fragid="S6.E9">
        <Math mode="display" xml:id="S6.E9.m1" tex="O\Big(poly\big(log(|V_{1}|)\big)+poly\big(log(|V_{2}|)\big)\dots poly\big(log(%&#10;|V_{m}|)\big)\Big)," text="O * (p * o * l * y * l * o * g * absolute-value@(V _ 1) + p * o * l * y * l * o * g * absolute-value@(V _ 2) * dots * p * o * l * y * l * o * g * absolute-value@(V _ m))" fragid="S6.E9.m1">
          <XMath>
            <XMApp punctuation=",">
              <XMTok meaning="times" role="MULOP">⁢</XMTok>
              <XMTok role="UNKNOWN" font="italic">O</XMTok>
              <XMDual>
                <XMRef idref="S6.E9.m1.1"/>
                <XMWrap>
                  <XMTok role="OPEN" stretchy="false" fontsize="160%">(</XMTok>
                  <XMApp xml:id="S6.E9.m1.1" fragid="S6.E9.m1.1">
                    <XMTok meaning="plus" role="ADDOP">+</XMTok>
                    <XMApp>
                      <XMTok meaning="times" role="MULOP">⁢</XMTok>
                      <XMTok role="UNKNOWN" font="italic">p</XMTok>
                      <XMTok role="UNKNOWN" font="italic">o</XMTok>
                      <XMTok role="UNKNOWN" font="italic">l</XMTok>
                      <XMTok role="UNKNOWN" font="italic">y</XMTok>
                      <XMDual>
                        <XMRef idref="S6.E9.m1.1.1"/>
                        <XMWrap>
                          <XMTok role="OPEN" stretchy="false" fontsize="120%">(</XMTok>
                          <XMApp xml:id="S6.E9.m1.1.1" fragid="S6.E9.m1.1.1">
                            <XMTok meaning="times" role="MULOP">⁢</XMTok>
                            <XMTok role="UNKNOWN" font="italic">l</XMTok>
                            <XMTok role="UNKNOWN" font="italic">o</XMTok>
                            <XMTok role="UNKNOWN" font="italic">g</XMTok>
                            <XMDual>
                              <XMRef idref="S6.E9.m1.1.1.1"/>
                              <XMWrap>
                                <XMTok role="OPEN" stretchy="false">(</XMTok>
                                <XMDual xml:id="S6.E9.m1.1.1.1" fragid="S6.E9.m1.1.1.1">
                                  <XMApp>
                                    <XMTok meaning="absolute-value"/>
                                    <XMRef idref="S6.E9.m1.1.1.1.1"/>
                                  </XMApp>
                                  <XMWrap>
                                    <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                    <XMApp xml:id="S6.E9.m1.1.1.1.1" fragid="S6.E9.m1.1.1.1.1">
                                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                                      <XMTok role="UNKNOWN" font="italic">V</XMTok>
                                      <XMTok meaning="1" role="NUMBER">1</XMTok>
                                    </XMApp>
                                    <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                  </XMWrap>
                                </XMDual>
                                <XMTok role="CLOSE" stretchy="false">)</XMTok>
                              </XMWrap>
                            </XMDual>
                          </XMApp>
                          <XMTok role="CLOSE" stretchy="false" fontsize="120%">)</XMTok>
                        </XMWrap>
                      </XMDual>
                    </XMApp>
                    <XMApp>
                      <XMTok meaning="times" role="MULOP">⁢</XMTok>
                      <XMTok role="UNKNOWN" font="italic">p</XMTok>
                      <XMTok role="UNKNOWN" font="italic">o</XMTok>
                      <XMTok role="UNKNOWN" font="italic">l</XMTok>
                      <XMTok role="UNKNOWN" font="italic">y</XMTok>
                      <XMDual>
                        <XMRef idref="S6.E9.m1.1.2"/>
                        <XMWrap>
                          <XMTok role="OPEN" stretchy="false" fontsize="120%">(</XMTok>
                          <XMApp xml:id="S6.E9.m1.1.2" fragid="S6.E9.m1.1.2">
                            <XMTok meaning="times" role="MULOP">⁢</XMTok>
                            <XMTok role="UNKNOWN" font="italic">l</XMTok>
                            <XMTok role="UNKNOWN" font="italic">o</XMTok>
                            <XMTok role="UNKNOWN" font="italic">g</XMTok>
                            <XMDual>
                              <XMRef idref="S6.E9.m1.1.2.1"/>
                              <XMWrap>
                                <XMTok role="OPEN" stretchy="false">(</XMTok>
                                <XMDual xml:id="S6.E9.m1.1.2.1" fragid="S6.E9.m1.1.2.1">
                                  <XMApp>
                                    <XMTok meaning="absolute-value"/>
                                    <XMRef idref="S6.E9.m1.1.2.1.1"/>
                                  </XMApp>
                                  <XMWrap>
                                    <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                    <XMApp xml:id="S6.E9.m1.1.2.1.1" fragid="S6.E9.m1.1.2.1.1">
                                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                                      <XMTok role="UNKNOWN" font="italic">V</XMTok>
                                      <XMTok meaning="2" role="NUMBER">2</XMTok>
                                    </XMApp>
                                    <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                  </XMWrap>
                                </XMDual>
                                <XMTok role="CLOSE" stretchy="false">)</XMTok>
                              </XMWrap>
                            </XMDual>
                          </XMApp>
                          <XMTok role="CLOSE" stretchy="false" fontsize="120%">)</XMTok>
                        </XMWrap>
                      </XMDual>
                      <XMTok name="dots" role="ID">…</XMTok>
                      <XMTok role="UNKNOWN" font="italic">p</XMTok>
                      <XMTok role="UNKNOWN" font="italic">o</XMTok>
                      <XMTok role="UNKNOWN" font="italic">l</XMTok>
                      <XMTok role="UNKNOWN" font="italic">y</XMTok>
                      <XMDual>
                        <XMRef idref="S6.E9.m1.1.3"/>
                        <XMWrap>
                          <XMTok role="OPEN" stretchy="false" fontsize="120%">(</XMTok>
                          <XMApp xml:id="S6.E9.m1.1.3" fragid="S6.E9.m1.1.3">
                            <XMTok meaning="times" role="MULOP">⁢</XMTok>
                            <XMTok role="UNKNOWN" font="italic">l</XMTok>
                            <XMTok role="UNKNOWN" font="italic">o</XMTok>
                            <XMTok role="UNKNOWN" font="italic">g</XMTok>
                            <XMDual>
                              <XMRef idref="S6.E9.m1.1.3.1"/>
                              <XMWrap>
                                <XMTok role="OPEN" stretchy="false">(</XMTok>
                                <XMDual xml:id="S6.E9.m1.1.3.1" fragid="S6.E9.m1.1.3.1">
                                  <XMApp>
                                    <XMTok meaning="absolute-value"/>
                                    <XMRef idref="S6.E9.m1.1.3.1.1"/>
                                  </XMApp>
                                  <XMWrap>
                                    <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                    <XMApp xml:id="S6.E9.m1.1.3.1.1" fragid="S6.E9.m1.1.3.1.1">
                                      <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                                      <XMTok role="UNKNOWN" font="italic">V</XMTok>
                                      <XMTok role="UNKNOWN" font="italic">m</XMTok>
                                    </XMApp>
                                    <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                  </XMWrap>
                                </XMDual>
                                <XMTok role="CLOSE" stretchy="false">)</XMTok>
                              </XMWrap>
                            </XMDual>
                          </XMApp>
                          <XMTok role="CLOSE" stretchy="false" fontsize="120%">)</XMTok>
                        </XMWrap>
                      </XMDual>
                    </XMApp>
                  </XMApp>
                  <XMTok role="CLOSE" stretchy="false" fontsize="160%">)</XMTok>
                </XMWrap>
              </XMDual>
            </XMApp>
          </XMath>
        </Math>
      </equation>
      <p>or more concisely:</p>
      <equation frefnum="(10)" refnum="10" xml:id="S6.E10" fragid="S6.E10">
        <Math mode="display" xml:id="S6.E10.m1" tex="O\Big(m\times poly\big(log(|V_{max}|)\big)\Big)," text="O * m * p * o * l * y * l * o * g * absolute-value@(V _ (m * a * x))" fragid="S6.E10.m1">
          <XMath>
            <XMApp punctuation=",">
              <XMTok meaning="times" role="MULOP">⁢</XMTok>
              <XMTok role="UNKNOWN" font="italic">O</XMTok>
              <XMDual>
                <XMRef idref="S6.E10.m1.1"/>
                <XMWrap>
                  <XMTok role="OPEN" stretchy="false" fontsize="160%">(</XMTok>
                  <XMApp xml:id="S6.E10.m1.1" fragid="S6.E10.m1.1">
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok meaning="times" role="MULOP">×</XMTok>
                      <XMTok role="UNKNOWN" font="italic">m</XMTok>
                      <XMTok role="UNKNOWN" font="italic">p</XMTok>
                    </XMApp>
                    <XMTok role="UNKNOWN" font="italic">o</XMTok>
                    <XMTok role="UNKNOWN" font="italic">l</XMTok>
                    <XMTok role="UNKNOWN" font="italic">y</XMTok>
                    <XMDual>
                      <XMRef idref="S6.E10.m1.1.1"/>
                      <XMWrap>
                        <XMTok role="OPEN" stretchy="false" fontsize="120%">(</XMTok>
                        <XMApp xml:id="S6.E10.m1.1.1" fragid="S6.E10.m1.1.1">
                          <XMTok meaning="times" role="MULOP">⁢</XMTok>
                          <XMTok role="UNKNOWN" font="italic">l</XMTok>
                          <XMTok role="UNKNOWN" font="italic">o</XMTok>
                          <XMTok role="UNKNOWN" font="italic">g</XMTok>
                          <XMDual>
                            <XMRef idref="S6.E10.m1.1.1.1"/>
                            <XMWrap>
                              <XMTok role="OPEN" stretchy="false">(</XMTok>
                              <XMDual xml:id="S6.E10.m1.1.1.1" fragid="S6.E10.m1.1.1.1">
                                <XMApp>
                                  <XMTok meaning="absolute-value"/>
                                  <XMRef idref="S6.E10.m1.1.1.1.1"/>
                                </XMApp>
                                <XMWrap>
                                  <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                  <XMApp xml:id="S6.E10.m1.1.1.1.1" fragid="S6.E10.m1.1.1.1.1">
                                    <XMTok role="SUBSCRIPTOP" scriptpos="post2"/>
                                    <XMTok role="UNKNOWN" font="italic">V</XMTok>
                                    <XMApp>
                                      <XMTok meaning="times" role="MULOP">⁢</XMTok>
                                      <XMTok role="UNKNOWN" font="italic">m</XMTok>
                                      <XMTok role="UNKNOWN" font="italic">a</XMTok>
                                      <XMTok role="UNKNOWN" font="italic">x</XMTok>
                                    </XMApp>
                                  </XMApp>
                                  <XMTok role="VERTBAR" stretchy="false">|</XMTok>
                                </XMWrap>
                              </XMDual>
                              <XMTok role="CLOSE" stretchy="false">)</XMTok>
                            </XMWrap>
                          </XMDual>
                        </XMApp>
                        <XMTok role="CLOSE" stretchy="false" fontsize="120%">)</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                  <XMTok role="CLOSE" stretchy="false" fontsize="160%">)</XMTok>
                </XMWrap>
              </XMDual>
            </XMApp>
          </XMath>
        </Math>
      </equation>
      <p>where <Math mode="inline" xml:id="S6.p2.m5" tex="|V_{max}|" text="absolute-value@(V _ (m * a * x))" fragid="S6.p2.m5"><XMath><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S6.p2.m5.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S6.p2.m5.1" fragid="S6.p2.m5.1"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">x</XMTok></XMApp></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual></XMath></Math> is to define the maximum number of nodes in a graph. Thus, this gives an exponentially faster implementation in comparison to the implementation on classical computers.
Note that if the adjacency matrices are not sparse, then the complexity for this part becomes <Math mode="inline" xml:id="S6.p2.m6" tex="O\big(m|V_{max}|^{2}\big)" text="O * m * (absolute-value@(V _ (m * a * x))) ^ 2" fragid="S6.p2.m6"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">O</XMTok><XMDual><XMRef idref="S6.p2.m6.1"/><XMWrap><XMTok role="OPEN" stretchy="false" fontsize="120%">(</XMTok><XMApp xml:id="S6.p2.m6.1" fragid="S6.p2.m6.1"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S6.p2.m6.1.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMApp xml:id="S6.p2.m6.1.1" fragid="S6.p2.m6.1.1"><XMTok role="SUBSCRIPTOP" scriptpos="post2"/><XMTok role="UNKNOWN" font="italic">V</XMTok><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">m</XMTok><XMTok role="UNKNOWN" font="italic">a</XMTok><XMTok role="UNKNOWN" font="italic">x</XMTok></XMApp></XMApp><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp></XMApp><XMTok role="CLOSE" stretchy="false" fontsize="120%">)</XMTok></XMWrap></XMDual></XMApp></XMath></Math> which is still exponentially fast in comparison to <Math mode="inline" xml:id="S6.p2.m7" tex="O\big(|E|^{m}\big)" text="O * (absolute-value@(E)) ^ m" fragid="S6.p2.m7"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">O</XMTok><XMDual><XMRef idref="S6.p2.m7.2"/><XMWrap><XMTok role="OPEN" stretchy="false" fontsize="120%">(</XMTok><XMApp xml:id="S6.p2.m7.2" fragid="S6.p2.m7.2"><XMTok role="SUPERSCRIPTOP" scriptpos="post2"/><XMDual><XMApp><XMTok meaning="absolute-value"/><XMRef idref="S6.p2.m7.1"/></XMApp><XMWrap><XMTok role="VERTBAR" stretchy="false">|</XMTok><XMTok role="UNKNOWN" xml:id="S6.p2.m7.1" font="italic" fragid="S6.p2.m7.1">E</XMTok><XMTok role="VERTBAR" stretchy="false">|</XMTok></XMWrap></XMDual><XMTok role="UNKNOWN" font="italic">m</XMTok></XMApp><XMTok role="CLOSE" stretchy="false" fontsize="120%">)</XMTok></XMWrap></XMDual></XMApp></XMath></Math> classical complexity.
Moreover, in the case of the incorporation of additional data: i.e., using <Math mode="inline" xml:id="S6.p2.m8" tex="A+B" text="A + B" fragid="S6.p2.m8"><XMath><XMApp><XMTok meaning="plus" role="ADDOP">+</XMTok><XMTok role="UNKNOWN" font="italic">A</XMTok><XMTok role="UNKNOWN" font="italic">B</XMTok></XMApp></XMath></Math> instead of <Math mode="inline" xml:id="S6.p2.m9" tex="A" text="A" fragid="S6.p2.m9"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math>; the above complexity arguments hold by assuming <Math mode="inline" xml:id="S6.p2.m10" tex="A" text="A" fragid="S6.p2.m10"><XMath><XMTok role="UNKNOWN" font="italic">A</XMTok></XMath></Math> and <Math mode="inline" xml:id="S6.p2.m11" tex="B" text="B" fragid="S6.p2.m11"><XMath><XMTok role="UNKNOWN" font="italic">B</XMTok></XMath></Math> commute and <Math mode="inline" xml:id="S6.p2.m12" tex="B" text="B" fragid="S6.p2.m12"><XMath><XMTok role="UNKNOWN" font="italic">B</XMTok></XMath></Math> is efficiently simulatable.</p>
    </para>
    <para xml:id="S6.p3" fragid="S6.p3">
      <p>The complexity of the matching part of the algorithm is related to the number of measurements applied to the system. If only one kind of measurement setting (measure a register alone and the rest together to draw the conditional probabilities) is used, then this part requires polynomial time (polynomial by the number of qubits) because it is related to the number of qubits.
On the other hand, if one also uses different combinations of the registers in the measurements and consider them together to match the nodes (This can be only useful when additional data is incorporated.), then the complexity to store the statistical results of the measurement outcomes and find matching from these outcomes may grow exponentially with the number of networks. However, as mentioned in Sec.<ref labelref="LABEL:sec:MatchingMN" href="#S4.SS2" title="4.2 Matching for Multiple Networks ‣ 4 Extracting Node Mappings From a Quantum State ‣ Quantum IsoRank: Efficient Alignment of Multiple PPI Networks"><text class="ltx_ref_tag">4.2</text></ref>, if there is no additional data is used, then the system is separable and all possible measurement settings produce the same output. Therefore, only one measurement setting can be used.</p>
    </para>
  </section>
  <section refnum="7" xml:id="S7" fragid="S7">
    <title><tag close=" ">7</tag>Conclusion</title>
    <para xml:id="S7.p1" fragid="S7.p1">
      <p>In this paper, we have presented a quantum approach for the alignment of multiple networks by adapting quantum phase estimation algorithm.
In particular, we have showed that the principal eigenvector of a stochastic matrix used in IsoRank algorithm for the alignment can be found exponentially more efficiently on quantum phase estimation algorithm.
Since the final quantum state representing the eigenvector in the phase estimation algorithm is not classically available, adapting a conditional measurement scheme, we have also showed a matching algorithm to obtain the alignment result from this state.
In addition, since the stochastic matrices are generally not Hermitian, we have also discussed how to approximate them for the simulation on quantum computers. Finally, we have used three simple networks and showed the numerical alignment results for them. While the approach discussed here follows mainly IsoRank algorithm, we believe it shall also pave the way for the applications of other spectral alignment methods on quantum computers.</p>
    </para>
  </section>
  <appendix frefnum="Appendix A" refnum="A" xml:id="A1" labels="LABEL:appendix:QFT" fragid="A1">
    <title><tag close=" ">Appendix A</tag>Quantum Fourier Transform</title>
    <toctitle><tag close=" ">A</tag>Quantum Fourier Transform</toctitle>
    <para xml:id="A1.p1" fragid="A1.p1">
      <p>The quantum Fourier transform (QFT) <cite class="ltx_citemacro_cite">[<ref href="#bib.bibx13" idref="bib.bibx13">Nielsen and Chuang(2010)</ref>]</cite> is the same as the classical discrete Fourier transform (DFT) applied to the amplitudes of a quantum state.
<!-- %**** ppi-main.tex Line 350 **** -->The quantum Fourier transform on an orthonormal basis
<Math mode="inline" xml:id="A1.p1.m1" tex="|\bm{0}\rangle,...|\bm{N-1}\rangle" text="list@(ket@(0), ldots * ket@(N - 1))" fragid="A1.p1.m1"><XMath><XMDual><XMApp><XMTok meaning="list"/><XMRef idref="A1.p1.m1.2"/><XMRef idref="A1.p1.m1.3"/></XMApp><XMWrap><XMDual xml:id="A1.p1.m1.2" fragid="A1.p1.m1.2"><XMApp><XMTok meaning="ket"/><XMRef idref="A1.p1.m1.1"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">|</XMTok><XMTok meaning="0" role="NUMBER" xml:id="A1.p1.m1.1" font="bold" fragid="A1.p1.m1.1">0</XMTok><XMTok name="rangle" role="CLOSE" stretchy="false">⟩</XMTok></XMWrap></XMDual><XMTok role="PUNCT">,</XMTok><XMApp xml:id="A1.p1.m1.3" fragid="A1.p1.m1.3"><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok name="ldots" role="ID">…</XMTok><XMDual><XMApp><XMTok meaning="ket"/><XMRef idref="A1.p1.m1.3.1"/></XMApp><XMWrap><XMTok role="OPEN" stretchy="false">|</XMTok><XMApp xml:id="A1.p1.m1.3.1" fragid="A1.p1.m1.3.1"><XMTok meaning="minus" role="ADDOP" font="bold">-</XMTok><XMTok role="UNKNOWN" font="bold italic">N</XMTok><XMTok meaning="1" role="NUMBER" font="bold">1</XMTok></XMApp><XMTok name="rangle" role="CLOSE" stretchy="false">⟩</XMTok></XMWrap></XMDual></XMApp></XMWrap></XMDual></XMath></Math> maps the quantum states as:</p>
      <equation frefnum="(11)" refnum="11" xml:id="A1.E11" fragid="A1.E11">
        <Math mode="display" xml:id="A1.E11.m1" tex="|j\rangle=\frac{1}{\sqrt{N}}\sum^{N-1}_{j=1}2^{\frac{2\pi i}{N}jk}|k\rangle." text="ket@(j) = (1 / square-root@(N)) * ((sum ^ (N - 1)) _ (j = 1))@(2 ^ (((2 * pi * i) / N) * j * k) * ket@(k))" fragid="A1.E11.m1">
          <XMath>
            <XMApp punctuation=".">
              <XMTok meaning="equals" role="RELOP">=</XMTok>
              <XMDual>
                <XMApp>
                  <XMTok meaning="ket"/>
                  <XMRef idref="A1.E11.m1.1"/>
                </XMApp>
                <XMWrap>
                  <XMTok role="OPEN" stretchy="false">|</XMTok>
                  <XMTok role="UNKNOWN" xml:id="A1.E11.m1.1" font="italic" fragid="A1.E11.m1.1">j</XMTok>
                  <XMTok name="rangle" role="CLOSE" stretchy="false">⟩</XMTok>
                </XMWrap>
              </XMDual>
              <XMApp>
                <XMTok meaning="times" role="MULOP">⁢</XMTok>
                <XMApp>
                  <XMTok mathstyle="display" meaning="divide" role="MULOP"/>
                  <XMTok meaning="1" role="NUMBER">1</XMTok>
                  <XMApp>
                    <XMTok meaning="square-root"/>
                    <XMTok role="UNKNOWN" font="italic">N</XMTok>
                  </XMApp>
                </XMApp>
                <XMApp>
                  <XMApp scriptpos="mid">
                    <XMTok role="SUBSCRIPTOP" scriptpos="mid3"/>
                    <XMApp scriptpos="mid">
                      <XMTok role="SUPERSCRIPTOP" scriptpos="mid3"/>
                      <XMTok mathstyle="display" meaning="sum" role="SUMOP" scriptpos="mid">∑</XMTok>
                      <XMApp>
                        <XMTok meaning="minus" role="ADDOP">-</XMTok>
                        <XMTok role="UNKNOWN" font="italic">N</XMTok>
                        <XMTok meaning="1" role="NUMBER">1</XMTok>
                      </XMApp>
                    </XMApp>
                    <XMApp>
                      <XMTok meaning="equals" role="RELOP">=</XMTok>
                      <XMTok role="UNKNOWN" font="italic">j</XMTok>
                      <XMTok meaning="1" role="NUMBER">1</XMTok>
                    </XMApp>
                  </XMApp>
                  <XMApp>
                    <XMTok meaning="times" role="MULOP">⁢</XMTok>
                    <XMApp>
                      <XMTok role="SUPERSCRIPTOP" scriptpos="post3"/>
                      <XMTok meaning="2" role="NUMBER">2</XMTok>
                      <XMApp>
                        <XMTok meaning="times" role="MULOP">⁢</XMTok>
                        <XMApp>
                          <XMTok mathstyle="script" meaning="divide" role="MULOP"/>
                          <XMApp>
                            <XMTok meaning="times" role="MULOP">⁢</XMTok>
                            <XMTok meaning="2" role="NUMBER">2</XMTok>
                            <XMTok name="pi" role="UNKNOWN" font="italic">π</XMTok>
                            <XMTok role="UNKNOWN" font="italic">i</XMTok>
                          </XMApp>
                          <XMTok role="UNKNOWN" font="italic">N</XMTok>
                        </XMApp>
                        <XMTok role="UNKNOWN" font="italic">j</XMTok>
                        <XMTok role="UNKNOWN" font="italic">k</XMTok>
                      </XMApp>
                    </XMApp>
                    <XMDual>
                      <XMApp>
                        <XMTok meaning="ket"/>
                        <XMRef idref="A1.E11.m1.2"/>
                      </XMApp>
                      <XMWrap>
                        <XMTok role="OPEN" stretchy="false">|</XMTok>
                        <XMTok role="UNKNOWN" xml:id="A1.E11.m1.2" font="italic" fragid="A1.E11.m1.2">k</XMTok>
                        <XMTok name="rangle" role="CLOSE" stretchy="false">⟩</XMTok>
                      </XMWrap>
                    </XMDual>
                  </XMApp>
                </XMApp>
              </XMApp>
            </XMApp>
          </XMath>
        </Math>
      </equation>
    </para>
    <para xml:id="A1.p2" fragid="A1.p2">
      <p>The quantum Fourier transform can be computed by using <Math mode="inline" xml:id="A1.p2.m1" tex="O(\log^{2}{N})" text="O * (logarithm ^ 2)@(N)" fragid="A1.p2.m1"><XMath><XMApp><XMTok meaning="times" role="MULOP">⁢</XMTok><XMTok role="UNKNOWN" font="italic">O</XMTok><XMDual><XMRef idref="A1.p2.m1.1"/><XMWrap><XMTok role="OPEN" stretchy="false">(</XMTok><XMApp xml:id="A1.p2.m1.1" fragid="A1.p2.m1.1"><XMApp><XMTok role="SUPERSCRIPTOP" scriptpos="post3"/><XMTok meaning="logarithm" role="OPFUNCTION">log</XMTok><XMTok meaning="2" role="NUMBER">2</XMTok></XMApp><XMTok role="UNKNOWN" font="italic">N</XMTok></XMApp><XMTok role="CLOSE" stretchy="false">)</XMTok></XMWrap></XMDual></XMApp></XMath></Math> elementary operations, which is exponentially faster than the classical discrete Fourier transform.</p>
    </para>
    <!-- %merlin.mbs apsrev4-1.bst 2010-07-25 4.21a (PWD, AO, DPC) hacked 
     %Control: key (0)
     %Control: author (8) initials jnrlst
     %Control: editor formatted (1) identically to author
     %Control: production of article title (-1) disabled
     %Control: page (0) single
     %Control: year (1) truncated
     %Control: production of eprint (0) enabled-->
  </appendix>
  <bibliography xml:id="bib" fragid="bib">
    <title>References</title>
    <biblist>
      <!-- %**** ppi-main.tex Line 375 **** 
     %**** ppi-main.tex Line 400 ****
     %¡/preamble¿-->
      <bibitem key="KLau2009" xml:id="bib.bibx1" fragid="bib.bibx1">
        <bibtag role="refnum">Klau(2009)</bibtag>
        <bibblock>G. Klau, “bibfield journal
“bibinfo journal BMC Bioinformatics“ “textbf “bibinfo volume
10,“ “bibinfo pages S59 (“bibinfo year 2009). </bibblock>
      </bibitem>
      <bibitem key="Kelley2004" xml:id="bib.bibx2" fragid="bib.bibx2">
        <bibtag role="refnum">Kelley <emph>et al.</emph>(2004)Kelley,
Yuan, Lewitter, Sharan,
Stockwell, and Ideker</bibtag>
        <bibblock>B<!-- %**** ppi-main.tex Line 425 **** -->. P. Kelley, B. Yuan,
F. Lewitter, R. Sharan, B. R. Stockwell,  and T. Ideker, “bibfield journal “bibinfo journal Nucleic Acids
Research“ “textbf “bibinfo volume 32,“ “bibinfo pages W83
(“bibinfo year 2004). </bibblock>
      </bibitem>
      <bibitem key="Koyuturk2006pairwise" xml:id="bib.bibx3" fragid="bib.bibx3">
        <bibtag role="refnum">Koyutürk <emph>et al.</emph>(2006)Koyutürk, Kim, Topkara, Subramaniam, Szpankowski, and Grama</bibtag>
        <bibblock>M. Koyutürk, Y. Kim,
U. Topkara, S. Subramaniam, W. Szpankowski,  and A. Grama, Journal of Computational Biology <text font="bold">13</text>, 182 (2006). </bibblock>
      </bibitem>
      <bibitem key="Li2007alignment" xml:id="bib.bibx4" fragid="bib.bibx4">
        <bibtag role="refnum">Li <emph>et al.</emph>(2007)Li,
Zhang, Wang, Zhang, and Chen</bibtag>
        <bibblock><!-- %**** ppi-main.tex Line 450 **** -->Z. Li, S. Zhang, Y. Wang, X.-S. Zhang,  and L. Chen, Bioinformatics <text font="bold">23</text>, 1631 (2007). </bibblock>
      </bibitem>
      <bibitem key="Zaslavskiy15062009" xml:id="bib.bibx5" fragid="bib.bibx5">
        <bibtag role="refnum">Zaslavskiy <emph>et al.</emph>(2009)Zaslavskiy, Bach, and Vert</bibtag>
        <bibblock>M. Zaslavskiy, F. Bach,  and J.-P. Vert, “bibfield journal “bibinfo
journal Bioinformatics“ “textbf “bibinfo volume 25,“ “bibinfo
pages i259 (“bibinfo year 2009). </bibblock>
      </bibitem>
      <bibitem key="Clark2014comparison" xml:id="bib.bibx6" fragid="bib.bibx6">
        <bibtag role="refnum">Clark and Kalita(2014)</bibtag>
        <bibblock>C. Clark and J. Kalita, B<!-- %**** ppi-main.tex Line 475 **** -->ioinformatics <text font="bold">30</text>, 2351 (2014). </bibblock>
      </bibitem>
      <bibitem key="PageRank" xml:id="bib.bibx7" fragid="bib.bibx7">
        <bibtag role="refnum">Page <emph>et al.</emph>(1999)Page,
Brin, Motwani, and Winograd</bibtag>
        <bibblock>L. Page, S. Brin, R. Motwani,  and T. Winograd, “emph “bibinfo title The PageRank
Citation Ranking: Bringing Order to the Web., Technical
Report 1999-66 (Stanford
InfoLab, 1999) previous number =
SIDL-WP-1999-0120. </bibblock>
      </bibitem>
      <bibitem key="Singh2007" xml:id="bib.bibx8" fragid="bib.bibx8">
        <bibtag role="refnum">Singh <emph>et al.</emph>(2007)Singh,
Xu, and Berger</bibtag>
        <bibblock>R. Singh, J. Xu,  and B. Berger, in “emph “bibinfo booktitle Research
in Computational Molecular Biology, Lecture Notes in
Computer Science, Vol. 4453, edited
by T. Speed and H. Huang (S<!-- %**** ppi-main.tex Line 500 **** -->pringer Berlin Heidelberg, 2007) pp. 16–31. </bibblock>
      </bibitem>
      <bibitem key="IsorankN2009" xml:id="bib.bibx9" fragid="bib.bibx9">
        <bibtag role="refnum">Liao <emph>et al.</emph>(2009)Liao,
Lu, Baym, 0001, and Berger</bibtag>
        <bibblock>C.-S. Liao, K. Lu, M. Baym, R. S. 0001,  and B. Berger, Bioinformatics <text font="bold">25</text> (2009). </bibblock>
      </bibitem>
      <bibitem key="Wang2009" xml:id="bib.bibx10" fragid="bib.bibx10">
        <bibtag role="refnum">Bayati <emph>et al.</emph>(2009)Bayati,
Gerritsen, Gleich, Saberi, and Wang</bibtag>
        <bibblock>M. Bayati, M. Gerritsen,
D. Gleich, A. Saberi,  and Y. Wang, in “emph “bibinfo booktitle Data Mining, 2009. ICDM
’09. Ninth IEEE International Conference on (2009) pp. 705–710. <!-- %**** ppi-main.tex Line 525 **** --></bibblock>
      </bibitem>
      <bibitem key="Noble2008" xml:id="bib.bibx11" fragid="bib.bibx11">
        <bibtag role="refnum">Nir <emph>et al.</emph>(2008)Nir,
Roded, and William Stafford</bibtag>
        <bibblock>Y. Nir, S. Roded,  and N. William Stafford, “bibfield journal “bibinfo journal Bioinformatics“ “textbf
“bibinfo volume 24,“ “bibinfo pages i200 (“bibinfo year
2008). </bibblock>
      </bibitem>
      <bibitem key="Daskin2014mna" xml:id="bib.bibx12" fragid="bib.bibx12">
        <bibtag role="refnum">Daskin <emph>et al.</emph>(2014)Daskin,
Grama, and Kais</bibtag>
        <bibblock>A. Daskin, A. Grama,  and S. Kais, “bibfield journal “bibinfo
journal Quantum Information Processing“ “textbf “bibinfo volume
13,“ “bibinfo pages 2653 (“bibinfo year 2014). </bibblock>
      </bibitem>
      <bibitem key="Nielsen2010quantum" xml:id="bib.bibx13" fragid="bib.bibx13">
        <bibtag role="refnum">Nielsen and Chuang(2010)</bibtag>
        <bibblock>M<!-- %**** ppi-main.tex Line 550 **** -->. A. Nielsen and I. L. Chuang, <emph>Quantum computation and
quantum information</emph> (Cambridge university press, 2010). </bibblock>
      </bibitem>
      <bibitem key="Shor1994algorithms" xml:id="bib.bibx14" fragid="bib.bibx14">
        <bibtag role="refnum">Shor(1994)</bibtag>
        <bibblock>P. W. Shor, in <emph>Foundations of
Computer Science, 1994 Proceedings., 35th Annual Symposium on</emph> (IEEE, 1994) pp. 124–134. </bibblock>
      </bibitem>
      <bibitem key="Grover1996fast" xml:id="bib.bibx15" fragid="bib.bibx15">
        <bibtag role="refnum">Grover(1996)</bibtag>
        <bibblock>L. K. Grover, in <emph>Proceedings of
the twenty-eighth annual ACM symposium on Theory of computing</emph> (ACM, 1996) pp. 212–219. </bibblock>
      </bibitem>
      <bibitem key="Kitaev1995" xml:id="bib.bibx16" fragid="bib.bibx16">
        <bibtag role="refnum">Kitaev(1995)</bibtag>
        <bibblock>A. Kitaev, “bibfield
journal “bibinfo journal arXiv:quant-ph/9511026“  (“bibinfo year
1995). </bibblock>
      </bibitem>
      <bibitem key="ClosestHermitian1975" xml:id="bib.bibx17" fragid="bib.bibx17">
        <bibtag role="refnum">Keller(1975)</bibtag>
        <bibblock><!-- %**** ppi-main.tex Line 575 **** -->J. B. Keller, “bibfield
journal “bibinfo journal Mathematics Magazine“ “textbf “bibinfo
volume 48,“ “bibinfo pages pp. 192 (“bibinfo year
1975). </bibblock>
      </bibitem>
      <bibitem key="Berry2007sparse" xml:id="bib.bibx18" fragid="bib.bibx18">
        <bibtag role="refnum">Berry <emph>et al.</emph>(2007)Berry,
Ahokas, Cleve, and Sanders</bibtag>
        <bibblock>D. Berry, G. Ahokas,
R. Cleve,  and B. Sanders, “bibfield journal “bibinfo journal
Communications in Mathematical Physics“ “textbf “bibinfo volume
270,“ “bibinfo pages 359 (“bibinfo year 2007). </bibblock>
      </bibitem>
      <bibitem key="Aharonov2003" xml:id="bib.bibx19" fragid="bib.bibx19">
        <bibtag role="refnum">Aharonov and Ta-Shma(2003)</bibtag>
        <bibblock>D. Aharonov and A. Ta-Shma, in <!-- %**** ppi-main.tex Line 600 **** -->“emph “bibinfo
booktitle Proceedings of the thirty-fifth annual ACM symposium on Theory
of computing, STOC ’03 (ACM, New York, NY, USA, 2003) pp. 20–29. </bibblock>
      </bibitem>
      <bibitem key="Childs2011" xml:id="bib.bibx20" fragid="bib.bibx20">
        <bibtag role="refnum">Childs and Kothari(2011)</bibtag>
        <bibblock>A. M. Childs and R. Kothari, in <emph>Theory of
Quantum Computation, Communication, and Cryptography</emph> (Springer, 2011) pp. 94–103. </bibblock>
      </bibitem>
    </biblist>
  </bibliography>
</document>
